import * as tsMod from "typescript";
import { SourceFile, Program, Expression, TaggedTemplateExpression } from "typescript";
import * as tsServer from "typescript/lib/tsserverlibrary";
import { SimpleType } from "ts-simple-type";
import { ComponentDefinition, ComponentDeclaration, ComponentMember, ComponentSlot, EventDeclaration, AnalyzeComponentsResult, ComponentDiagnostic } from "web-component-analyzer";
interface HtmlDataAttrValue {
    name: string;
    description?: string;
}
interface HtmlDataAttr {
    name: string;
    description?: string;
    values?: HtmlDataAttrValue[];
    valueSet?: string;
}
interface HtmlDataTag {
    name: string;
    description?: string;
    attributes: HtmlDataAttr[];
}
interface HtmlDataValueSet {
    name: string;
    values: HtmlDataAttrValue[];
}
interface HtmlDataV1 {
    version: 1;
    tags?: HtmlDataTag[];
    globalAttributes?: HtmlDataAttr[];
    valueSets?: HtmlDataValueSet[];
}
type HtmlData = HtmlDataV1;
type HtmlDataCollection = {
    tags: HtmlTag[];
    attrs: HtmlAttr[];
    events: HtmlEvent[];
};
interface HtmlTag {
    tagName: string;
    description?: string;
    builtIn?: boolean;
    global?: boolean;
    declaration?: ComponentDeclaration;
    attributes: HtmlAttr[];
    properties: HtmlProp[];
    events: HtmlEvent[];
    slots: HtmlSlot[];
}
type HtmlTagMemberKind = "attribute" | "property";
interface HtmlMemberBase {
    kind?: HtmlTagMemberKind;
    builtIn?: boolean;
    required?: boolean;
    description?: string;
    declaration?: ComponentMember;
    name?: string;
    fromTagName?: string;
    related?: HtmlMember[];
    getType(): SimpleType;
}
interface HtmlAttr extends HtmlMemberBase {
    kind: "attribute";
    name: string;
    related?: HtmlMember[];
}
interface HtmlProp extends HtmlMemberBase {
    kind: "property";
    name: string;
    related?: HtmlMember[];
}
type HtmlMember = HtmlAttr | HtmlProp;
interface HtmlEvent {
    name: string;
    description?: string;
    declaration?: EventDeclaration;
    builtIn?: boolean;
    global?: boolean;
    fromTagName?: string;
    related?: HtmlEvent[];
    getType(): SimpleType;
}
interface HtmlSlot {
    name: string;
    fromTagName?: string;
    description?: string;
    declaration?: ComponentSlot;
}
type HtmlAttrTarget = HtmlEvent | HtmlMember;
interface Range {
    start: number;
    end: number;
}
type LitHtmlAttributeModifier = "." | "?" | "@";
declare const LIT_HTML_PROP_ATTRIBUTE_MODIFIER = ".";
declare const LIT_HTML_BOOLEAN_ATTRIBUTE_MODIFIER = "?";
declare const LIT_HTML_EVENT_LISTENER_ATTRIBUTE_MODIFIER = "@";
declare const LIT_HTML_ATTRIBUTE_MODIFIERS: LitHtmlAttributeModifier[];
declare const DIAGNOSTIC_SOURCE = "lit-plugin";
declare const TS_IGNORE_FLAG = "@ts-ignore";
declare const VERSION = "1.1.11";
interface IHtmlNodeSourceCodeLocation extends Range {
    name: Range;
    startTag: Range;
    endTag?: Range;
}
declare enum HtmlNodeKind {
    NODE = "NODE",
    SVG = "SVG",
    STYLE = "STYLE"
}
interface IHtmlNodeBase {
    tagName: string;
    location: IHtmlNodeSourceCodeLocation;
    attributes: HtmlNodeAttr[];
    parent?: HtmlNode;
    children: HtmlNode[];
    selfClosed: boolean;
}
interface IHtmlNode extends IHtmlNodeBase {
    kind: HtmlNodeKind.NODE;
}
interface IHtmlNodeStyleTag extends IHtmlNodeBase {
    kind: HtmlNodeKind.STYLE;
}
interface IHtmlNodeSvgTag extends IHtmlNodeBase {
    kind: HtmlNodeKind.SVG;
}
type HtmlNode = IHtmlNode | IHtmlNodeStyleTag | IHtmlNodeSvgTag; // eslint-disable-next-line @typescript-eslint/no-explicit-any
// eslint-disable-next-line @typescript-eslint/no-explicit-any
// eslint-disable-next-line @typescript-eslint/no-explicit-any
declare enum HtmlNodeAttrKind {
    EVENT_LISTENER = "EVENT_LISTENER",
    ATTRIBUTE = "ATTRIBUTE",
    BOOLEAN_ATTRIBUTE = "BOOLEAN_ATTRIBUTE",
    PROPERTY = "PROPERTY"
}
interface IHtmlNodeAttrSourceCodeLocation extends Range {
    name: Range;
}
interface IHtmlNodeAttrBase {
    name: string;
    modifier?: LitHtmlAttributeModifier;
    location: IHtmlNodeAttrSourceCodeLocation;
    assignment?: HtmlNodeAttrAssignment;
    htmlNode: HtmlNode;
}
interface IHtmlNodeAttrEventListener extends IHtmlNodeAttrBase {
    kind: HtmlNodeAttrKind.EVENT_LISTENER;
    modifier: "@";
}
interface IHtmlNodeAttrProp extends IHtmlNodeAttrBase {
    kind: HtmlNodeAttrKind.PROPERTY;
    modifier: ".";
}
interface IHtmlNodeBooleanAttribute extends IHtmlNodeAttrBase {
    kind: HtmlNodeAttrKind.BOOLEAN_ATTRIBUTE;
    modifier: "?";
}
interface IHtmlNodeAttr extends IHtmlNodeAttrBase {
    kind: HtmlNodeAttrKind.ATTRIBUTE;
    modifier: undefined;
}
type HtmlNodeAttr = IHtmlNodeAttrEventListener | IHtmlNodeAttrProp | IHtmlNodeAttr | IHtmlNodeBooleanAttribute; // eslint-disable-next-line @typescript-eslint/no-explicit-any
// eslint-disable-next-line @typescript-eslint/no-explicit-any
// eslint-disable-next-line @typescript-eslint/no-explicit-any
declare enum HtmlNodeAttrAssignmentKind {
    BOOLEAN = "BOOLEAN",
    EXPRESSION = "EXPRESSION",
    STRING = "STRING",
    MIXED = "MIXED"
}
interface IHtmlNodeAttrAssignmentBase {
    location?: Range;
    htmlAttr: HtmlNodeAttr;
}
interface IHtmlNodeAttrAssignmentExpression extends IHtmlNodeAttrAssignmentBase {
    kind: HtmlNodeAttrAssignmentKind.EXPRESSION;
    location: Range;
    expression: Expression;
}
interface IHtmlNodeAttrAssignmentString extends IHtmlNodeAttrAssignmentBase {
    kind: HtmlNodeAttrAssignmentKind.STRING;
    location: Range;
    value: string;
}
interface IHtmlNodeAttrAssignmentBoolean extends IHtmlNodeAttrAssignmentBase {
    kind: HtmlNodeAttrAssignmentKind.BOOLEAN;
}
interface IHtmlNodeAttrAssignmentMixed extends IHtmlNodeAttrAssignmentBase {
    kind: HtmlNodeAttrAssignmentKind.MIXED;
    location: Range;
    values: (Expression | string)[];
}
type HtmlNodeAttrAssignment = IHtmlNodeAttrAssignmentBoolean | IHtmlNodeAttrAssignmentExpression | IHtmlNodeAttrAssignmentString | IHtmlNodeAttrAssignmentMixed;
interface VirtualDocument {
    fileName: string;
    location: Range;
    text: string;
    getPartsAtOffsetRange(range?: Range): (Expression | string)[];
    scPositionToOffset(position: number): number;
    offsetToSCPosition(offset: number): number;
}
declare class TextDocument {
    virtualDocument: VirtualDocument;
    constructor(virtualDocument: VirtualDocument);
}
interface SourceFileRange {
    start: number;
    end: number;
}
interface DocumentRange {
    start: number;
    end: number;
    document?: TextDocument;
}
declare enum LitHtmlDiagnosticKind {
    MISSING_IMPORT = "MISSING_IMPORT",
    MISSING_REQUIRED_ATTRS = "MISSING_REQUIRED_ATTRIBUTES",
    UNKNOWN_TARGET = "UNKNOWN_TARGET",
    UNKNOWN_TAG = "UNKNOWN_TAG",
    TAG_NOT_CLOSED = "TAG_NOT_CLOSED",
    BOOL_MOD_ON_NON_BOOL = "BOOL_MOD_ON_NON_BOOL",
    PROPERTY_NEEDS_EXPRESSION = "PROPERTY_NEEDS_EXPRESSION",
    NO_EVENT_LISTENER_FUNCTION = "NO_EVENT_LISTENER_FUNCTION",
    PRIMITIVE_NOT_ASSIGNABLE_TO_COMPLEX = "PRIMITIVE_NOT_BINDING_IN_ATTRIBUTE_BINDING",
    COMPLEX_NOT_BINDABLE_IN_ATTRIBUTE_BINDING = "COMPLEX_NOT_BINDABLE_IN_ATTRIBUTE_BINDING",
    EXPRESSION_ONLY_ASSIGNABLE_WITH_BOOLEAN_BINDING = "EXPRESSION_ONLY_ASSIGNABLE_WITH_BOOLEAN_BINDING",
    INVALID_ATTRIBUTE_EXPRESSION_TYPE_UNDEFINED = "INVALID_ATTRIBUTE_EXPRESSION_TYPE_UNDEFINED",
    INVALID_ATTRIBUTE_EXPRESSION_TYPE_NULL = "INVALID_ATTRIBUTE_EXPRESSION_TYPE_NULL",
    INVALID_ATTRIBUTE_EXPRESSION_TYPE = "INVALID_ATTRIBUTE_EXPRESSION_TYPE",
    INVALID_SLOT_NAME = "INVALID_SLOT_NAME",
    MISSING_SLOT_ATTRIBUTE = "MISSING_SLOT_ATTRIBUTE",
    DIRECTIVE_NOT_ALLOWED_HERE = "DIRECTIVE_NOT_ALLOWED_HERE",
    INVALID_MIXED_BINDING = "INVALID_MIXED_BINDING",
    LEGACY_SYNTAX = "LEGACY_SYNTAX"
}
type LitDiagnosticSeverity = "error" | "warning";
interface LitDiagnosticBase {
    location: SourceFileRange;
    message: string;
    fix?: string;
    source: LitAnalyzerRuleName;
    suggestion?: string;
    severity: LitDiagnosticSeverity;
}
interface LitDocumentDiagnosticBase extends LitDiagnosticBase {
    location: DocumentRange;
}
interface LitSourceFileDiagnosticBase extends LitDiagnosticBase {
    file: SourceFile;
}
interface LitHtmlDiagnosticUnknownTag extends LitDocumentDiagnosticBase {
    kind: LitHtmlDiagnosticKind.UNKNOWN_TAG;
    suggestedName?: string;
    htmlNode: HtmlNode;
}
interface LitHtmlDiagnosticUnknownMember extends LitDocumentDiagnosticBase {
    kind: LitHtmlDiagnosticKind.UNKNOWN_TARGET;
    htmlAttr: HtmlNodeAttr;
    suggestedTarget?: HtmlAttrTarget;
}
interface LitHtmlDiagnosticMissingImport extends LitDocumentDiagnosticBase {
    kind: LitHtmlDiagnosticKind.MISSING_IMPORT;
    htmlNode: HtmlNode;
    definition: ComponentDefinition;
    importPath: string;
}
interface LitHtmlDiagnosticMissingProps extends LitDocumentDiagnosticBase {
    kind: LitHtmlDiagnosticKind.MISSING_REQUIRED_ATTRS;
    attrs: HtmlAttr[];
    htmlNode: HtmlNode;
}
interface LitHtmlDiagnosticTagNotClosed extends LitDocumentDiagnosticBase {
    kind: LitHtmlDiagnosticKind.TAG_NOT_CLOSED;
    htmlNode: HtmlNode;
}
interface LitHtmlDiagnosticHtmlBoolMod extends LitDocumentDiagnosticBase {
    kind: LitHtmlDiagnosticKind.BOOL_MOD_ON_NON_BOOL;
    htmlAttr: HtmlNodeAttr;
    typeA: SimpleType;
    typeB: SimpleType;
}
interface LitHtmlDiagnosticPrimitiveNotAssignableToComplex extends LitDocumentDiagnosticBase {
    kind: LitHtmlDiagnosticKind.PRIMITIVE_NOT_ASSIGNABLE_TO_COMPLEX;
    htmlAttr: HtmlNodeAttr;
    typeA: SimpleType;
    typeB: SimpleType;
}
interface LitHtmlDiagnosticHtmlNoEventListenerFunction extends LitDocumentDiagnosticBase {
    kind: LitHtmlDiagnosticKind.NO_EVENT_LISTENER_FUNCTION;
    typeB: SimpleType;
}
interface LitHtmlDiagnosticHtmlInvalidAttributeExpressionType extends LitDocumentDiagnosticBase {
    kind: LitHtmlDiagnosticKind.INVALID_ATTRIBUTE_EXPRESSION_TYPE;
    htmlAttr: HtmlNodeAttr;
    typeA: SimpleType;
    typeB: SimpleType;
}
interface LitHtmlDiagnosticHtmlInvalidAttributeExpressionTypeUndefined extends LitDocumentDiagnosticBase {
    kind: LitHtmlDiagnosticKind.INVALID_ATTRIBUTE_EXPRESSION_TYPE_UNDEFINED;
    htmlAttr: IHtmlNodeAttr & {
        assignment: IHtmlNodeAttrAssignmentExpression;
    };
    typeA: SimpleType;
    typeB: SimpleType;
}
interface LitHtmlDiagnosticHtmlInvalidAttributeExpressionTypeNull extends LitDocumentDiagnosticBase {
    kind: LitHtmlDiagnosticKind.INVALID_ATTRIBUTE_EXPRESSION_TYPE_NULL;
    htmlAttr: IHtmlNodeAttr & {
        assignment: IHtmlNodeAttrAssignmentExpression;
    };
    typeA: SimpleType;
    typeB: SimpleType;
}
interface LitHtmlDiagnosticHtmlExpressionOnlyAssignableWithBooleanBinding extends LitDocumentDiagnosticBase {
    kind: LitHtmlDiagnosticKind.EXPRESSION_ONLY_ASSIGNABLE_WITH_BOOLEAN_BINDING;
    htmlAttr: HtmlNodeAttr;
    typeA: SimpleType;
    typeB: SimpleType;
}
interface LitHtmlDiagnosticComplexNotBindableInAttributeBinding extends LitDocumentDiagnosticBase {
    kind: LitHtmlDiagnosticKind.COMPLEX_NOT_BINDABLE_IN_ATTRIBUTE_BINDING;
    htmlAttr: HtmlNodeAttr;
    typeA: SimpleType;
    typeB: SimpleType;
}
interface LitHtmlDiagnosticHtmlPropertyNeedsExpression extends LitDocumentDiagnosticBase {
    kind: LitHtmlDiagnosticKind.PROPERTY_NEEDS_EXPRESSION;
}
interface LitHtmlDiagnosticHtmlDirectiveNotAllowedHere extends LitDocumentDiagnosticBase {
    kind: LitHtmlDiagnosticKind.DIRECTIVE_NOT_ALLOWED_HERE;
}
interface LitHtmlDiagnosticInvalidSlotName extends LitDocumentDiagnosticBase {
    kind: LitHtmlDiagnosticKind.INVALID_SLOT_NAME;
    validSlotNames: (string | undefined)[];
}
interface LitHtmlDiagnosticMissingSlotAttr extends LitDocumentDiagnosticBase {
    kind: LitHtmlDiagnosticKind.MISSING_SLOT_ATTRIBUTE;
    htmlNode: HtmlNode;
    validSlotNames: string[];
}
interface LitHtmlDiagnosticInvalidMixedBinding extends LitDocumentDiagnosticBase {
    kind: LitHtmlDiagnosticKind.INVALID_MIXED_BINDING;
}
interface LitHtmlDiagnosticLegacySyntax extends LitDocumentDiagnosticBase {
    kind: LitHtmlDiagnosticKind.LEGACY_SYNTAX;
}
type LitHtmlDiagnostic = LitHtmlDiagnosticUnknownTag | LitHtmlDiagnosticMissingImport | LitHtmlDiagnosticMissingProps | LitHtmlDiagnosticHtmlBoolMod | LitHtmlDiagnosticUnknownMember | LitHtmlDiagnosticHtmlDirectiveNotAllowedHere | LitHtmlDiagnosticPrimitiveNotAssignableToComplex | LitHtmlDiagnosticHtmlInvalidAttributeExpressionType | LitHtmlDiagnosticHtmlInvalidAttributeExpressionTypeUndefined | LitHtmlDiagnosticHtmlInvalidAttributeExpressionTypeNull | LitHtmlDiagnosticHtmlNoEventListenerFunction | LitHtmlDiagnosticComplexNotBindableInAttributeBinding | LitHtmlDiagnosticHtmlPropertyNeedsExpression | LitHtmlDiagnosticHtmlExpressionOnlyAssignableWithBooleanBinding | LitHtmlDiagnosticInvalidSlotName | LitHtmlDiagnosticMissingSlotAttr | LitHtmlDiagnosticInvalidMixedBinding | LitHtmlDiagnosticTagNotClosed | LitHtmlDiagnosticLegacySyntax;
interface LitCssDiagnostic extends LitDocumentDiagnosticBase {
}
interface LitSourceFileDiagnostic extends LitSourceFileDiagnosticBase {
}
type LitDiagnostic = LitHtmlDiagnostic | LitCssDiagnostic | LitSourceFileDiagnostic;
type LitAnalyzerRuleName = "no-unknown-tag-name" | "no-missing-import" | "no-unclosed-tag" | "no-unknown-attribute" | "no-unknown-property" | "no-unknown-event" | "no-unknown-slot" | "no-unintended-mixed-binding" | "no-invalid-boolean-binding" | "no-expressionless-property-binding" | "no-noncallable-event-binding" | "no-boolean-in-attribute-binding" | "no-complex-attribute-binding" | "no-nullable-attribute-binding" | "no-incompatible-type-binding" | "no-invalid-directive-binding" | "no-incompatible-property-type" | "no-unknown-property-converter" | "no-invalid-attribute-name" | "no-invalid-tag-name" | "no-invalid-css" | "no-legacy-attribute";
declare const ALL_RULE_NAMES: LitAnalyzerRuleName[];
type LitAnalyzerRuleSeverity = "off" | "warn" | "warning" | "error" | 0 | 1 | 2 | true | false;
type LitAnalyzerRules = Partial<Record<LitAnalyzerRuleName, LitAnalyzerRuleSeverity | [LitAnalyzerRuleSeverity]>>;
declare function ruleSeverity(rules: LitAnalyzerConfig | LitAnalyzerRules, ruleName: LitAnalyzerRuleName): LitAnalyzerRuleSeverity;
declare function isRuleDisabled(config: LitAnalyzerConfig, ruleName: LitAnalyzerRuleName): boolean;
declare function isRuleEnabled(config: LitAnalyzerConfig, ruleName: LitAnalyzerRuleName): boolean;
declare function litDiagnosticRuleSeverity(config: LitAnalyzerConfig, ruleName: LitAnalyzerRuleName): LitDiagnosticSeverity;
type LitAnalyzerLogging = "off" | "error" | "warn" | "debug" | "verbose";
type LitSecuritySystem = "off" | "ClosureSafeTypes";
interface LitAnalyzerConfig {
    strict: boolean;
    rules: LitAnalyzerRules;
    securitySystem: LitSecuritySystem;
    disable: boolean;
    logging: LitAnalyzerLogging;
    cwd: string;
    format: {
        disable: boolean;
    };
    htmlTemplateTags: string[];
    cssTemplateTags: string[];
    dontShowSuggestions: boolean;
    dontSuggestConfigChanges: boolean;
    globalTags: string[];
    globalAttributes: string[];
    globalEvents: string[];
    customHtmlData: (string | HtmlData)[] | string | HtmlData;
}
/**
 * Parses a partial user configuration and returns a full options object with defaults.
 * @param userOptions
 */
declare function makeConfig(userOptions?: Partial<LitAnalyzerConfig>): LitAnalyzerConfig;
declare function makeRules(userOptions: Partial<LitAnalyzerConfig>): LitAnalyzerRules;
interface RuleModule {
    name: LitAnalyzerRuleName;
    visitHtmlNode?(node: HtmlNode, context: LitAnalyzerRequest): LitHtmlDiagnostic[] | void;
    visitHtmlAttribute?(attribute: HtmlNodeAttr, context: LitAnalyzerRequest): LitHtmlDiagnostic[] | void;
    visitHtmlAssignment?(assignment: HtmlNodeAttrAssignment, context: LitAnalyzerRequest): LitHtmlDiagnostic[] | void;
}
/* eslint-disable @typescript-eslint/no-explicit-any */
interface LitAnalyzerLogger {
    level: LitAnalyzerLoggerLevel;
    debug(...args: any[]): void;
    error(...args: any[]): void;
    warn(...args: any[]): void;
    verbose(...args: any[]): void;
}
declare enum LitAnalyzerLoggerLevel {
    OFF = 0,
    ERROR = 1,
    WARN = 2,
    DEBUG = 3,
    VERBOSE = 4
}
declare class DefaultLitAnalyzerLogger implements LitAnalyzerLogger {
    level: LitAnalyzerLoggerLevel;
    /**
     * Logs if this.level >= DEBUG
     * @param args
     */
    debug(...args: any[]): void;
    /**
     * Logs if this.level >= ERROR
     * @param args
     */
    error(...args: any[]): void;
    /**
     * Logs if level >= WARN
     * @param args
     */
    warn(...args: any[]): void;
    /**
     * Logs if level >= VERBOSE
     * @param args
     */
    verbose(...args: any[]): void;
    private log;
    protected severityPrefix(level: LitAnalyzerLoggerLevel): string;
}
interface AnalyzerDefinitionStore {
    getAnalysisResultForFile(sourceFile: SourceFile): AnalyzeComponentsResult | undefined;
    getAnalysisDiagnosticsInFile(sourceFile: SourceFile): ComponentDiagnostic[];
    getDefinitionsWithDeclarationInFile(sourceFile: SourceFile): ComponentDefinition[];
    getDefinitionForTagName(tagName: string): ComponentDefinition | undefined;
    getDefinitionsInFile(sourceFile: SourceFile): ComponentDefinition[];
}
interface AnalyzerDependencyStore {
    hasTagNameBeenImported(fileName: string, tagName: string): boolean;
} //importedComponentDefinitionsInFile = new Map<string, ComponentDefinition[]>();
/**
 * Returns if a component for a specific file has been imported.
 * @param fileName
 * @param tagName
 */
/*hasTagNameBeenImported(fileName: string, tagName: string): boolean {
for (const file of this.importedComponentDefinitionsInFile.get(fileName) || []) {
if (file.tagName === tagName) {
return true;
}
}

return false;
}*/
//importedComponentDefinitionsInFile = new Map<string, ComponentDefinition[]>();
/**
 * Returns if a component for a specific file has been imported.
 * @param fileName
 * @param tagName
 */
/*hasTagNameBeenImported(fileName: string, tagName: string): boolean {
for (const file of this.importedComponentDefinitionsInFile.get(fileName) || []) {
if (file.tagName === tagName) {
return true;
}
}

return false;
}*/
//importedComponentDefinitionsInFile = new Map<string, ComponentDefinition[]>();
/**
 * Returns if a component for a specific file has been imported.
 * @param fileName
 * @param tagName
 */
/*hasTagNameBeenImported(fileName: string, tagName: string): boolean {
for (const file of this.importedComponentDefinitionsInFile.get(fileName) || []) {
if (file.tagName === tagName) {
return true;
}
}

return false;
}*/
interface AnalyzerDocumentStore {
    getDocumentAtPosition(sourceFile: SourceFile, position: number, options: LitAnalyzerConfig): TextDocument | undefined;
    getDocumentsInFile(sourceFile: SourceFile, config: LitAnalyzerConfig): TextDocument[];
}
interface AnalyzerHtmlStore {
    /*absorbAnalysisResult(sourceFile: SourceFile, result: AnalyzeComponentsResult): void;
    absorbSubclassExtension(name: string, extension: HtmlTag): void;
    absorbCollection(collection: HtmlDataCollection, register: HtmlStoreDataSource): void;
    forgetTagsDefinedInFile(sourceFile: SourceFile): void;*/
    /*getDefinitionsWithDeclarationInFile(sourceFile: SourceFile): ComponentDefinition[];
    getDefinitionForTagName(tagName: string): ComponentDefinition | undefined;
    getDefinitionsInFile(sourceFile: SourceFile): ComponentDefinition[];
    hasTagNameBeenImported(fileName: string, tagName: string): boolean;*/
    getHtmlTag(htmlNode: HtmlNode | string): HtmlTag | undefined;
    getGlobalTags(): Iterable<HtmlTag>;
    getAllAttributesForTag(htmlNode: HtmlNode | string): Iterable<HtmlAttr>;
    getAllPropertiesForTag(htmlNode: HtmlNode | string): Iterable<HtmlProp>;
    getAllEventsForTag(htmlNode: HtmlNode | string): Iterable<HtmlEvent>;
    getAllSlotsForTag(htmlNode: HtmlNode | string): Iterable<HtmlSlot>;
    getHtmlAttrTarget(htmlNodeAttr: IHtmlNodeAttrProp): HtmlProp | undefined;
    getHtmlAttrTarget(htmlNodeAttr: IHtmlNodeAttr | IHtmlNodeBooleanAttribute): HtmlAttr | undefined;
    getHtmlAttrTarget(htmlNodeAttr: IHtmlNodeAttr | IHtmlNodeBooleanAttribute | IHtmlNodeAttrProp): HtmlMember | undefined;
    getHtmlAttrTarget(htmlNodeAttr: IHtmlNodeAttrEventListener): HtmlEvent | undefined;
    getHtmlAttrTarget(htmlNodeAttr: HtmlNodeAttr): HtmlAttrTarget | undefined;
    getHtmlAttrTarget(htmlNodeAttr: HtmlNodeAttr): HtmlAttrTarget | undefined;
}
interface LitAnalyzerContext {
    readonly ts: typeof tsMod;
    readonly program: Program;
    readonly project: tsServer.server.Project | undefined;
    readonly config: LitAnalyzerConfig;
    readonly htmlStore: AnalyzerHtmlStore;
    readonly dependencyStore: AnalyzerDependencyStore;
    readonly documentStore: AnalyzerDocumentStore;
    readonly definitionStore: AnalyzerDefinitionStore;
    readonly logger: LitAnalyzerLogger;
    readonly rules: RuleModule[];
    updateConfig(config: LitAnalyzerConfig): void;
    updateDependencies(file: SourceFile): void;
    updateComponents(file: SourceFile): void;
}
interface LitAnalyzerRequest extends LitAnalyzerContext {
    file: SourceFile;
    document: TextDocument;
}
interface LitPluginContextHandler {
    ts?: typeof tsMod;
    getProgram(): Program;
    getProject?(): tsServer.server.Project;
}
interface LitClosingTagInfo {
    newText: string;
}
interface DocumentTextChange {
    range: DocumentRange;
    newText: string;
}
interface TextChange {
    range: SourceFileRange;
    newText: string;
}
declare enum CodeActionKind {
    DOCUMENT_TEXT_CHANGE = "TEXT_CHANGE",
    IMPORT_COMPONENT = "IMPORT_COMPONENT"
}
interface CodeActionTextChange {
    kind: CodeActionKind.DOCUMENT_TEXT_CHANGE;
    change: DocumentTextChange;
}
interface CodeActionImportComponent {
    kind: CodeActionKind.IMPORT_COMPONENT;
    importPath: string;
}
type LitCodeFixAction = CodeActionTextChange | CodeActionImportComponent;
declare enum CodeFixKind {
    RENAME = "RENAME",
    ADD_TEXT = "ADD_TEXT",
    CHANGE_LIT_MODIFIER = "CHANGE_LIT_MODIFIER",
    IMPORT_COMPONENT = "IMPORT_COMPONENT"
}
interface CodeFixBase {
    message: string;
    htmlReport: LitHtmlDiagnostic;
    actions: LitCodeFixAction[];
}
interface CodeFixAddText extends CodeFixBase {
    kind: CodeFixKind.ADD_TEXT;
}
interface CodeFixRename extends CodeFixBase {
    kind: CodeFixKind.RENAME;
    htmlReport: LitHtmlDiagnosticUnknownMember | LitHtmlDiagnosticUnknownTag;
}
interface CodeFixChangeLitModifier extends CodeFixBase {
    kind: CodeFixKind.CHANGE_LIT_MODIFIER;
    htmlReport: LitHtmlDiagnosticHtmlBoolMod | LitHtmlDiagnosticPrimitiveNotAssignableToComplex;
}
interface CodeFixImportComponent extends CodeFixBase {
    kind: CodeFixKind.IMPORT_COMPONENT;
    htmlReport: LitHtmlDiagnosticMissingImport;
}
type LitCodeFix = CodeFixRename | CodeFixChangeLitModifier | CodeFixImportComponent | CodeFixAddText;
type LitTargetKind = "memberFunctionElement" | "functionElement" | "constructorImplementationElement" | "variableElement" | "classElement" | "interfaceElement" | "moduleElement" | "memberVariableElement" | "constElement" | "enumElement" | "keyword" | "constElement" | "alias" | "moduleElement" | "member" | "label" | "unknown";
interface LitCompletion {
    name: string;
    kind: LitTargetKind;
    kindModifiers?: "color";
    insert: string;
    range?: DocumentRange;
    importance?: "high" | "medium" | "low";
    documentation?(): string | undefined;
}
interface LitCompletionDetails {
    name: string;
    kind: LitTargetKind;
    primaryInfo: string;
    secondaryInfo?: string;
}
declare enum DefinitionKind {
    COMPONENT = "COMPONENT",
    MEMBER = "MEMBER",
    EVENT = "EVENT"
}
interface DefinitionBase {
    fromRange: DocumentRange;
}
interface DefinitionComponent extends DefinitionBase {
    kind: DefinitionKind.COMPONENT;
    target: ComponentDeclaration;
}
interface DefinitionMember extends DefinitionBase {
    kind: DefinitionKind.MEMBER;
    target: ComponentMember;
}
interface DefinitionEvent extends DefinitionBase {
    kind: DefinitionKind.EVENT;
    target: EventDeclaration;
}
type LitDefinition = DefinitionComponent | DefinitionMember | DefinitionEvent;
interface LitFormatEdit {
    range: DocumentRange;
    newText: string;
}
declare enum LitOutliningSpanKind {
    Comment = "comment",
    Region = "region",
    Code = "code",
    Imports = "imports"
}
interface LitOutliningSpan {
    location: DocumentRange;
    bannerText: string;
    autoCollapse?: boolean;
    kind: LitOutliningSpanKind;
}
interface LitQuickInfo {
    range: DocumentRange;
    primaryInfo: string;
    secondaryInfo?: string;
}
declare class VirtualAstDocument implements VirtualDocument {
    readonly fileName: string;
    readonly location: Range;
    private readonly parts;
    private _text?;
    get text(): string;
    getPartsAtOffsetRange(range: Range): (Expression | string)[];
    scPositionToOffset(position: number): number;
    offsetToSCPosition(offset: number): number;
    constructor(parts: (Expression | string)[], location: Range, fileName: string);
    constructor(astNode: TaggedTemplateExpression);
    protected substituteExpression(length: number, expression: Expression, prev: string, next: string | undefined): string;
}
declare class VirtualAstHtmlDocument extends VirtualAstDocument {
    protected substituteExpression(length: number, expression: Expression): string;
}
declare class HtmlDocument extends TextDocument {
    rootNodes: HtmlNode[];
    constructor(virtualDocument: VirtualAstHtmlDocument, rootNodes: HtmlNode[]);
    htmlAttrAreaAtOffset(offset: number | Range): HtmlNode | undefined;
    htmlAttrAssignmentAtOffset(offset: number | Range): HtmlNodeAttr | undefined;
    htmlAttrNameAtOffset(offset: number | Range): HtmlNodeAttr | undefined;
    htmlNodeNameAtOffset(offset: number | Range): HtmlNode | undefined;
    htmlNodeOrAttrAtOffset(offset: number | Range): HtmlNode | HtmlNodeAttr | undefined;
    /**
     * Finds the closest node to offset.
     * This method can be used to find out which tag to close in the HTML.
     * @param offset
     */
    htmlNodeClosestToOffset(offset: number): HtmlNode | undefined;
    findAttr(test: (node: HtmlNodeAttr) => boolean): HtmlNodeAttr | undefined;
    findNode(test: (node: HtmlNode) => boolean): HtmlNode | undefined;
    mapNodes<T>(map: (node: HtmlNode) => T): T[];
    private mapFindOne;
}
interface RenameInfoBase {
    kind: LitTargetKind;
    displayName: string;
    fullDisplayName: string;
    range: SourceFileRange | DocumentRange;
}
interface RenameHtmlNodeInfo extends RenameInfoBase {
    document: HtmlDocument;
    target: ComponentDefinition | HtmlNode;
}
interface RenameComponentDefinitionInfo extends RenameInfoBase {
    target: ComponentDefinition;
}
type LitRenameInfo = RenameHtmlNodeInfo | RenameComponentDefinitionInfo;
interface LitRenameLocation {
    fileName: string;
    prefixText?: string;
    suffixText?: string;
    range: DocumentRange | SourceFileRange;
}
declare class LitAnalyzer {
    private context;
    private litHtmlDocumentAnalyzer;
    private litCssDocumentAnalyzer;
    constructor(context: LitAnalyzerContext);
    getOutliningSpansInFile(file: SourceFile): LitOutliningSpan[];
    getDefinitionAtPosition(file: SourceFile, position: number): LitDefinition | undefined;
    getQuickInfoAtPosition(file: SourceFile, position: number): LitQuickInfo | undefined;
    getRenameInfoAtPosition(file: SourceFile, position: number): LitRenameInfo | undefined;
    getRenameLocationsAtPosition(file: SourceFile, position: number): LitRenameLocation[];
    getClosingTagAtPosition(file: SourceFile, position: number): LitClosingTagInfo | undefined;
    getCompletionDetailsAtPosition(file: SourceFile, position: number, name: string): LitCompletionDetails | undefined;
    getCompletionsAtPosition(file: SourceFile, position: number): LitCompletion[] | undefined;
    getDiagnosticsInFile(file: SourceFile): LitDiagnostic[];
    getCodeFixesAtPositionRange(file: SourceFile, positionRange: Range): LitCodeFix[];
    getFormatEditsInFile(file: SourceFile, settings: ts.FormatCodeSettings): LitFormatEdit[];
    /*private sendRequest<FuncName extends keyof LitDocumentAnalyzer, Params extends Parameters<NonNullable<LitDocumentAnalyzer[FuncName]>>>( funcName: "getCompletionsAtOffset", { file, document }: { file: SourceFile; document: TextDocument }, offset: number);
    private sendRequest<FuncName extends keyof LitDocumentAnalyzer, Params extends Parameters<NonNullable<LitDocumentAnalyzer[FuncName]>>>( funcName: FuncName, { file, document }: { file: SourceFile; document: TextDocument }, arg1: number ) {
    const request = this.makeRequest({ file, document });
    
    const func = (() => {
    if (document instanceof CssDocument) {
    //return this.litCssDocumentAnalyzer[funcName];
    } else if (document instanceof HtmlDocument) {
    return this.litHtmlDocumentAnalyzer[funcName];
    }
    })() as LitDocumentAnalyzer[FuncName];
    
    if (func == null) return undefined;
    
    switch (funcName) {
    case "getCompletionsAtOffset":
    return func(document, arg1, request);
    }
    }*/
    /*private sendRequest<
    FuncName extends keyof LitDocumentAnalyzer,
    Params extends Parameters<NonNullable<LitDocumentAnalyzer[FuncName]>>,
    Arg = Params extends { length: infer L } ? (L extends 1 ? never : (L extends 2 ? never : Params[1])) : never
    >(funcName: FuncName, { file, document }: { file: SourceFile; document: TextDocument }, arg1: Arg) {
    const request = this.makeRequest({ file, document });
    
    const func = (() => {
    if (document instanceof CssDocument) {
    return this.litCssDocumentAnalyzer[funcName];
    } else if (document instanceof HtmlDocument) {
    return this.litHtmlDocumentAnalyzer[funcName];
    }
    })();
    
    if (arg1 == null) {
    }
    }*/
    private makeRequest;
    private getDocumentAndOffsetAtPosition;
    private getDocumentsInFile;
}
declare class DefaultAnalyzerDefinitionStore implements AnalyzerDefinitionStore {
    private analysisResultForFile;
    private definitionForTagName;
    absorbAnalysisResult(sourceFile: SourceFile, result: AnalyzeComponentsResult): void;
    forgetAnalysisResultForFile(sourceFile: SourceFile): void;
    getAnalysisResultForFile(sourceFile: SourceFile): AnalyzeComponentsResult | undefined;
    getAnalysisDiagnosticsInFile(sourceFile: SourceFile): ComponentDiagnostic[];
    getDefinitionsWithDeclarationInFile(sourceFile: SourceFile): ComponentDefinition[];
    getDefinitionForTagName(tagName: string): ComponentDefinition | undefined;
    getDefinitionsInFile(sourceFile: SourceFile): ComponentDefinition[];
}
declare class DefaultAnalyzerDependencyStore implements AnalyzerDependencyStore {
    importedComponentDefinitionsInFile: Map<string, ComponentDefinition[]>;
    absorbComponentDefinitionsForFile(sourceFile: SourceFile, result: ComponentDefinition[]): void;
    /**
     * Returns if a component for a specific file has been imported.
     * @param fileName
     * @param tagName
     */
    hasTagNameBeenImported(fileName: string, tagName: string): boolean;
}
declare class DefaultAnalyzerDocumentStore {
    getDocumentAtPosition(sourceFile: SourceFile, position: number, options: LitAnalyzerConfig): TextDocument | undefined;
    getDocumentsInFile(sourceFile: SourceFile, config: LitAnalyzerConfig): TextDocument[];
}
declare enum HtmlDataSourceKind {
    DECLARED = 0,
    USER = 1,
    BUILD_IN = 2
}
declare class DefaultAnalyzerHtmlStore implements AnalyzerHtmlStore {
    private dataSource;
    absorbSubclassExtension(name: string, extension: HtmlTag): void;
    absorbCollection(collection: HtmlDataCollection, register: HtmlDataSourceKind): void;
    forgetCollection(collection: Partial<Record<keyof HtmlDataCollection, string[]>>, register: HtmlDataSourceKind): void;
    getHtmlTag(htmlNode: HtmlNode | string): HtmlTag | undefined;
    getGlobalTags(): Iterable<HtmlTag>;
    getAllAttributesForTag(htmlNode: HtmlNode | string): Iterable<HtmlAttr>;
    getAllPropertiesForTag(htmlNode: HtmlNode | string): Iterable<HtmlProp>;
    getAllEventsForTag(htmlNode: HtmlNode | string): Iterable<HtmlEvent>;
    getAllSlotsForTag(htmlNode: HtmlNode | string): Iterable<HtmlSlot>;
    getHtmlAttrTarget(htmlNodeAttr: IHtmlNodeAttrProp): HtmlProp | undefined;
    getHtmlAttrTarget(htmlNodeAttr: IHtmlNodeAttr | IHtmlNodeBooleanAttribute): HtmlAttr | undefined;
    getHtmlAttrTarget(htmlNodeAttr: IHtmlNodeAttr | IHtmlNodeBooleanAttribute | IHtmlNodeAttrProp): HtmlMember | undefined;
    getHtmlAttrTarget(htmlNodeAttr: IHtmlNodeAttrEventListener): HtmlEvent | undefined;
    getHtmlAttrTarget(htmlNodeAttr: HtmlNodeAttr): HtmlAttrTarget | undefined;
}
type ChangedSourceFileIterator = ((sourceFiles: readonly SourceFile[]) => Iterable<SourceFile>) & {
    invalidate(sourceFile: SourceFile): void;
}; /**
 * Yields source files that have changed since last time this function was called.
 */
/**
 * Yields source files that have changed since last time this function was called.
 */
/**
 * Yields source files that have changed since last time this function was called.
 */
declare class DefaultLitAnalyzerContext implements LitAnalyzerContext {
    private handler;
    protected componentSourceFileIterator: ChangedSourceFileIterator;
    protected hasAnalyzedSubclassExtensions: boolean;
    protected _config: LitAnalyzerConfig;
    get ts(): typeof tsMod;
    get program(): Program;
    get project(): tsServer.server.Project | undefined;
    get config(): LitAnalyzerConfig;
    readonly htmlStore: DefaultAnalyzerHtmlStore;
    readonly dependencyStore: DefaultAnalyzerDependencyStore;
    readonly documentStore: DefaultAnalyzerDocumentStore;
    readonly definitionStore: DefaultAnalyzerDefinitionStore;
    readonly logger: DefaultLitAnalyzerLogger;
    get rules(): RuleModule[];
    updateConfig(config: LitAnalyzerConfig): void;
    updateDependencies(file: SourceFile): void;
    updateComponents(file: SourceFile): void;
    private get checker();
    constructor(handler: LitPluginContextHandler);
    private findInvalidatedComponents;
    private findComponentsInFile;
    private analyzeSubclassExtensions;
    private findDependenciesInFile;
}
/**
 * The main function of the cli.
 */
declare function cli(): Promise<void>;
export { LitAnalyzer, LitHtmlAttributeModifier, LIT_HTML_PROP_ATTRIBUTE_MODIFIER, LIT_HTML_BOOLEAN_ATTRIBUTE_MODIFIER, LIT_HTML_EVENT_LISTENER_ATTRIBUTE_MODIFIER, LIT_HTML_ATTRIBUTE_MODIFIERS, DIAGNOSTIC_SOURCE, TS_IGNORE_FLAG, VERSION, LitAnalyzerRuleName, ALL_RULE_NAMES, LitAnalyzerRuleSeverity, LitAnalyzerRules, ruleSeverity, isRuleDisabled, isRuleEnabled, litDiagnosticRuleSeverity, LitAnalyzerLogging, LitSecuritySystem, LitAnalyzerConfig, makeConfig, makeRules, LitAnalyzerContext, LitAnalyzerRequest, LitPluginContextHandler, LitAnalyzerLogger, LitAnalyzerLoggerLevel, DefaultLitAnalyzerLogger, DefaultLitAnalyzerContext, LitClosingTagInfo, CodeFixKind, CodeFixBase, CodeFixAddText, CodeFixRename, CodeFixChangeLitModifier, CodeFixImportComponent, LitCodeFix, DocumentTextChange, TextChange, CodeActionKind, CodeActionTextChange, CodeActionImportComponent, LitCodeFixAction, LitCompletion, LitCompletionDetails, DefinitionKind, DefinitionBase, DefinitionComponent, DefinitionMember, DefinitionEvent, LitDefinition, LitHtmlDiagnosticKind, LitDiagnosticSeverity, LitDiagnosticBase, LitDocumentDiagnosticBase, LitSourceFileDiagnosticBase, LitHtmlDiagnosticUnknownTag, LitHtmlDiagnosticUnknownMember, LitHtmlDiagnosticMissingImport, LitHtmlDiagnosticMissingProps, LitHtmlDiagnosticTagNotClosed, LitHtmlDiagnosticHtmlBoolMod, LitHtmlDiagnosticPrimitiveNotAssignableToComplex, LitHtmlDiagnosticHtmlNoEventListenerFunction, LitHtmlDiagnosticHtmlInvalidAttributeExpressionType, LitHtmlDiagnosticHtmlInvalidAttributeExpressionTypeUndefined, LitHtmlDiagnosticHtmlInvalidAttributeExpressionTypeNull, LitHtmlDiagnosticHtmlExpressionOnlyAssignableWithBooleanBinding, LitHtmlDiagnosticComplexNotBindableInAttributeBinding, LitHtmlDiagnosticHtmlPropertyNeedsExpression, LitHtmlDiagnosticHtmlDirectiveNotAllowedHere, LitHtmlDiagnosticInvalidSlotName, LitHtmlDiagnosticMissingSlotAttr, LitHtmlDiagnosticInvalidMixedBinding, LitHtmlDiagnosticLegacySyntax, LitHtmlDiagnostic, LitCssDiagnostic, LitSourceFileDiagnostic, LitDiagnostic, LitFormatEdit, LitOutliningSpanKind, LitOutliningSpan, LitQuickInfo, SourceFileRange, DocumentRange, RenameInfoBase, RenameHtmlNodeInfo, RenameComponentDefinitionInfo, LitRenameInfo, LitRenameLocation, LitTargetKind, cli };
//# sourceMappingURL=index.cjs.d.ts.map