import * as tsModule from "typescript";
import { Declaration, Identifier, InterfaceDeclaration, Node, PropertyDeclaration, PropertySignature, SetAccessorDeclaration, StringLiteral, Symbol, SyntaxKind, TypeChecker, JSDocTag, CallExpression, Expression, ObjectLiteralExpression, JSDoc, Type, SourceFile, Program } from "typescript";
import { SimpleType } from "ts-simple-type";
declare type VisibilityKind = "public" | "protected" | "private";
interface AstContext {
    ts: typeof tsModule;
    checker: TypeChecker;
}
/**
 * Resolves all relevant declarations of a specific node. Defaults to "interfaces and classes".
 * @param node
 * @param context
 */
declare function resolveDeclarations(node: Node, context: {
    checker: TypeChecker;
    ts: typeof tsModule;
}): Declaration[];
declare function isAliasSymbol(symbol: Symbol, ts: typeof tsModule): boolean;
/**
 * Returns if a name is private (starts with "_" or "#");
 * @param name	 * @param name
 */
declare function isNamePrivate(name: string): boolean;
/**
 * Returns if a node is not readable and static.
 * This function is used because modifiers have not been added to the output yet.
 * @param node
 * @param ts
 */
declare function isMemberAndWritable(node: Node, ts: typeof tsModule): boolean;
/**
 * Returns if a node is public looking at its modifiers.
 * @param node
 * @param ts
 */
declare function isNodeWritableMember(node: Node, ts: typeof tsModule): boolean;
/**
 * Returns if a number has a flag
 * @param num
 * @param flag
 */
declare function hasFlag(num: number, flag: number): boolean;
/**
 * Returns if a node has a specific modifier.
 * @param node
 * @param modifierKind
 */
declare function hasModifier(node: Node, modifierKind: SyntaxKind): boolean;
/**
 * Returns the visibility of a node
 * @param node	 * @param node
 * @param ts	 * @param ts
 */
declare function getMemberVisibilityFromNode(node: PropertyDeclaration | PropertySignature | SetAccessorDeclaration | Node, ts: typeof tsModule): VisibilityKind | undefined;
/**
 * Returns all keys and corresponding interface/class declarations for keys in an interface.
 * @param interfaceDeclaration
 * @param ts
 * @param checker
 */
declare function getInterfaceKeys(interfaceDeclaration: InterfaceDeclaration, { ts, checker }: AstContext): {
    key: string;
    keyNode: StringLiteral | Identifier;
    identifier?: Node;
    declaration: Declaration;
}[];
declare function isPropertyRequired(property: PropertySignature | PropertyDeclaration, checker: TypeChecker): boolean;
declare function isNodeInDeclarationFile(node: Node): boolean;
/**
 * Find a node recursively walking up the tree using parent nodes.
 * @param node
 * @param test
 */
declare function findParent<T = Node>(node: Node | undefined, test: (node: Node) => boolean): T | undefined;
/**
 * Find a node recursively walking down the children of the tree. Depth first search.
 * @param node
 * @param test
 */
declare function findChild<T = Node>(node: Node | undefined, test: (node: Node) => node is T & Node): T | undefined;
declare function getNodeSourceFileLang(node: Node): "js" | "ts";
declare function getLeadingCommentForNode(node: Node, ts: typeof tsModule): string | undefined;
interface Context {
    ts: typeof tsModule;
    checker?: TypeChecker;
    depth?: number;
}
/**
 * Takes a node and tries to resolve a constant value from it.
 * Returns undefined if no constant value can be resolved.
 * @param node
 * @param context
 */
declare function resolveNodeValue(node: Node | undefined, context: Context): {
    value: string | number | boolean | undefined | null;
    node: Node;
} | undefined;
declare type ComponentFeature = "member" | "method" | "cssproperty" | "csspart" | "event" | "slot";
declare const ALL_COMPONENT_FEATURES: ComponentFeature[];
/**
 * Configuration to give when analyzing components.
 */
interface AnalyzerConfig {
    analyzeLibDom?: boolean;
    analyzeLib?: boolean;
    excludedDeclarationNames?: string[];
    features?: ComponentFeature[];
}
interface JsDocTagParsed {
    tag: string;
    name?: string;
    type?: string;
    optional?: boolean;
    default?: string;
    description?: string;
}
interface JsDocTag {
    node?: JSDocTag;
    comment?: string;
    tag: string;
    parsed: () => JsDocTagParsed;
}
interface JsDoc {
    node?: JSDoc;
    description?: string;
    tags?: JsDocTag[];
}
interface ComponentCssPart {
    name: string;
    jsDoc: JsDoc | undefined;
}
interface ComponentCssProperty {
    name: string;
    jsDoc: JsDoc | undefined;
    type?: string;
}
interface ComponentEvent {
    name: string;
    node: Node;
    jsDoc: JsDoc | undefined;
    type: () => SimpleType | Type;
    typeHint?: string;
    visibility?: VisibilityKind;
}
interface LitElementPropertyConfig {
    type?: SimpleType | string;
    attribute?: string | boolean;
    node?: {
        type?: Node;
        attribute?: Node;
    };
    hasConverter?: boolean;
    default?: any;
    reflect?: boolean;
}
declare type ComponentMemberKind = "property" | "attribute";
declare type ComponentMemberReflectKind = "to-attribute" | "to-property" | "both";
interface ComponentMemberBase {
    kind: ComponentMemberKind;
    node: Node;
    jsDoc: JsDoc | undefined;
    typeHint?: string;
    type: undefined | (() => Type | SimpleType);
    meta?: LitElementPropertyConfig;
    visibility?: VisibilityKind;
    reflect?: ComponentMemberReflectKind;
    required?: boolean;
    deprecated?: boolean | string;
    default?: any;
}
interface ComponentMemberProperty extends ComponentMemberBase {
    kind: "property";
    propName: string;
    attrName?: string;
}
interface ComponentMemberAttribute extends ComponentMemberBase {
    kind: "attribute";
    attrName: string;
    propName?: undefined;
}
declare type ComponentMember = ComponentMemberProperty | ComponentMemberAttribute;
interface ComponentMethod {
    name: string;
    jsDoc: JsDoc | undefined;
    node?: Node;
    visibility?: VisibilityKind;
}
interface ComponentSlot {
    name?: string;
    jsDoc: JsDoc | undefined;
    permittedTagNames?: string[];
}
interface InheritanceTreeClause {
    kind: "mixin" | "interface" | "class";
    identifier: Identifier;
    horizontalInherits?: InheritanceTreeClause[];
    resolved?: InheritanceTreeNode[];
}
interface InheritanceTreeNode {
    node: Node;
    identifier: Identifier | undefined;
    inherits?: InheritanceTreeClause[];
}
interface ComponentDeclaration {
    inheritanceTree: InheritanceTreeNode;
    declarationNodes: Set<Node>;
    jsDoc: JsDoc | undefined;
    members: ComponentMember[];
    methods: ComponentMethod[];
    events: ComponentEvent[];
    slots: ComponentSlot[];
    cssProperties: ComponentCssProperty[];
    cssParts: ComponentCssPart[];
    deprecated?: boolean | string;
}
declare type PriorityKind = "low" | "medium" | "high";
interface DefinitionNodeResult {
    tagName: string;
    declarationNode: Node;
    identifierNode?: Node;
    tagNameNode?: Node;
    analyzerFlavor?: AnalyzerFlavor;
}
interface ComponentMemberResult {
    priority: PriorityKind;
    member: ComponentMember;
}
interface FeatureVisitReturnTypeMap {
    member: ComponentMemberResult;
    method: ComponentMethod;
    cssproperty: ComponentCssProperty;
    csspart: ComponentCssPart;
    event: ComponentEvent;
    slot: ComponentSlot;
}
interface ComponentFeatureCollection {
    memberResults: ComponentMemberResult[];
    methods: ComponentMethod[];
    events: ComponentEvent[];
    slots: ComponentSlot[];
    cssProperties: ComponentCssProperty[];
    cssParts: ComponentCssPart[];
}
declare type FeatureAnalyzeVisitMap = {
    [K in ComponentFeature]: (node: Node, context: AnalyzerVisitContext) => FeatureVisitReturnTypeMap[K][] | undefined;
};
declare type FeatureRefineVisitMap = {
    [K in ComponentFeature]: (feature: FeatureVisitReturnTypeMap[K], context: AnalyzerVisitContext) => FeatureVisitReturnTypeMap[K] | FeatureVisitReturnTypeMap[K][] | undefined;
};
interface AnalyzerFlavor {
    excludeNode?(node: Node, context: AnalyzerVisitContext): boolean | undefined;
    discoverDefinitions?(node: Node, context: AnalyzerVisitContext): DefinitionNodeResult[] | undefined;
    discoverInheritance?(node: Node, context: AnalyzerVisitContext): InheritanceTreeClause[] | undefined;
    discoverFeatures?: Partial<FeatureAnalyzeVisitMap>;
    refineFeature?: Partial<FeatureRefineVisitMap>;
    refineDeclaration?(declaration: ComponentDeclaration, context: AnalyzerVisitContext): ComponentDeclaration | undefined;
}
interface AnalyzerVisitContext {
    checker: TypeChecker;
    ts: typeof tsModule;
    config: AnalyzerConfig;
    flavors: AnalyzerFlavor[];
    emitContinue?(): void;
    cache: {
        featureCollection: WeakMap<Node, ComponentFeatureCollection>;
    };
}
/**
 * Visits custom element component definitions.
 * @param node
 * @param context
 */
declare function discoverDefinitions(node: Node, { ts, checker }: AnalyzerVisitContext): DefinitionNodeResult[] | undefined;
declare function lazy<T>(callback: () => T): () => T;
/**
 * Returns jsdoc for a given node.
 * @param node
 * @param tagNames
 * @param ts
 */
declare function getJsDoc(node: Node, ts: typeof tsModule): JsDoc | undefined;
declare function getJsDoc(node: Node, tagNames: string[], ts: typeof tsModule): JsDoc | undefined;
/**
 * Converts a given string to a SimpleType
 * Defaults to ANY
 * See http://usejsdoc.org/tags-type.html
 * @param str
 */
declare function parseJsDocTypeExpression(str: string): SimpleType;
/**
 * Finds a @type jsdoc tag in the jsdoc and returns the corresponding simple type
 * @param jsDoc
 */
declare function getJsDocType(jsDoc: JsDoc): SimpleType | undefined;
declare function discoverEvents(node: Node, context: AnalyzerVisitContext): ComponentEvent[] | undefined;
declare function discoverInheritance(node: Node, context: AnalyzerVisitContext): InheritanceTreeClause[] | undefined;
/**
 * Relax the type so that for example "string literal" become "string" and "function" become "any"
 * This is used for javascript files to provide type checking with Typescript type inferring
 * @param type
 */
declare function relaxType(type: SimpleType): SimpleType;
declare function discoverMembers(node: Node, context: AnalyzerVisitContext): ComponentMemberResult[] | undefined;
declare function discoverMethods(node: Node, context: AnalyzerVisitContext): ComponentMethod[] | undefined;
declare function excludeNode(node: Node, context: AnalyzerVisitContext): boolean | undefined;
declare const refineFeature: AnalyzerFlavor["refineFeature"];
declare class CustomElementFlavor implements AnalyzerFlavor {
    excludeNode: typeof excludeNode;
    discoverDefinitions: typeof discoverDefinitions;
    discoverFeatures: {
        member: typeof discoverMembers;
        event: typeof discoverEvents;
        method: typeof discoverMethods;
    };
    refineFeature: Partial<FeatureRefineVisitMap> | undefined;
    discoverInheritance: typeof discoverInheritance;
}
declare function parseJsDocForNode<T>(node: Node, tagNames: string[], transform: (tagNode: JSDocTag | undefined, parsed: JsDocTagParsed) => T | undefined, context: AnalyzerVisitContext): T[] | undefined;
declare function discoverDefinitions_$0(node: Node, context: AnalyzerVisitContext): DefinitionNodeResult[] | undefined;
declare const discoverFeatures: AnalyzerFlavor["discoverFeatures"];
declare function refineDeclaration(declaration: ComponentDeclaration, context: AnalyzerVisitContext): {
    deprecated: string | boolean;
    inheritanceTree: InheritanceTreeNode;
    declarationNodes: Set<Node>;
    jsDoc: JsDoc | undefined;
    members: ComponentMember[];
    methods: ComponentMethod[];
    events: ComponentEvent[];
    slots: ComponentSlot[];
    cssProperties: ComponentCssProperty[];
    cssParts: ComponentCssPart[];
} | undefined;
declare const refineFeature_$0: AnalyzerFlavor["refineFeature"];
declare class JsDocFlavor implements AnalyzerFlavor {
    discoverDefinitions: typeof discoverDefinitions_$0;
    discoverFeatures: Partial<FeatureAnalyzeVisitMap> | undefined;
    refineFeature: Partial<FeatureRefineVisitMap> | undefined;
    refineDeclaration: typeof refineDeclaration;
}
declare function discoverDefinitions_$0(node: Node, context: AnalyzerVisitContext): DefinitionNodeResult[] | undefined;
declare class JSXFlavor implements AnalyzerFlavor {
    discoverDefinitions: typeof discoverDefinitions_$0;
}
/**
 * Visits lit-element related definitions.
 * Specifically it finds the usage of the @customElement decorator.
 * @param node
 * @param context
 */
declare function discoverDefinitions_$0(node: Node, context: AnalyzerVisitContext): DefinitionNodeResult[] | undefined;
/**
 * Converts from snake case to camel case
 * @param str
 */
declare function dashToCamelCase(str: string): string;
/**
 * Converts from camel case to snake case
 * @param str
 */
declare function camelToDashCase(str: string): string;
/**
 * Returns a potential lit element property decorator.
 * @param node
 * @param context
 */
declare function getLitElementPropertyDecorator(node: Node, context: AnalyzerVisitContext): undefined | CallExpression;
/**
 * Returns a potential lit property decorator configuration.
 * @param node
 * @param context
 */
declare function getLitElementPropertyDecoratorConfig(node: Node, context: AnalyzerVisitContext): undefined | LitElementPropertyConfig;
/**
 * Parses an object literal expression and returns a lit property configuration.
 * @param node
 * @param context
 */
declare function getLitPropertyOptions(node: ObjectLiteralExpression, context: AnalyzerVisitContext): LitElementPropertyConfig;
declare function parseLitPropertyOption({ kind, initializer, config }: {
    kind: string | undefined;
    initializer: Expression;
    config: LitElementPropertyConfig;
}, context: AnalyzerVisitContext): LitElementPropertyConfig;
/**
 * Parses lit-related declaration members.
 * This is primary by looking at the "@property" decorator and the "static get properties()".
 * @param node
 * @param context
 */
declare function discoverMembers_$0(node: Node, context: AnalyzerVisitContext): ComponentMemberResult[] | undefined;
declare function excludeNode_$0(node: Node, context: AnalyzerVisitContext): boolean | undefined;
declare class LitElementFlavor implements AnalyzerFlavor {
    excludeNode: typeof excludeNode_$0;
    discoverDefinitions: typeof discoverDefinitions_$0;
    discoverFeatures: {
        member: typeof discoverMembers_$0;
    };
}
interface ComponentDefinition {
    identifierNodes: Set<Node>;
    tagNameNodes: Set<Node>;
    tagName: string;
    fromLib: boolean;
    declaration: () => ComponentDeclaration;
}
/**
 * Options to give when analyzing components
 */
interface AnalyzerOptions {
    checker: TypeChecker;
    ts?: typeof tsModule;
    flavors?: AnalyzerFlavor[];
    config?: AnalyzerConfig;
}
/**
 * The result returned after components have been analyzed.
 */
interface AnalyzerResult {
    sourceFile: SourceFile;
    componentDefinitions: ComponentDefinition[];
    globalEvents: ComponentEvent[];
    globalMembers: ComponentMember[];
}
declare type ModifierKind = "readonly";
interface TransformerConfig {
    visibility: VisibilityKind;
    markdown?: {
        titleLevel?: number;
    };
}
declare type TransformerKind = "md" | "markdown" | "json" | "vscode" | "debug";
declare type TransformerFunction = (results: AnalyzerResult[], program: Program, config: TransformerConfig) => string;
interface HtmlDataValue {
    name: string;
    description?: string;
}
interface HtmlDataValueSet {
    name: string;
    values: HtmlDataValue[];
}
interface HtmlDataMember {
    name: string;
    description?: string;
    values?: HtmlDataValue[];
    valueSet?: string;
    jsDoc?: string;
    type?: any;
    attribute?: string;
}
interface HtmlDataAttribute extends HtmlDataMember {
    default?: string;
}
interface HtmlDataProperty extends HtmlDataMember {
    default?: string;
}
interface HtmlDataSlot extends HtmlDataMember {
}
interface HtmlDataEvent extends HtmlDataMember {
}
interface HtmlDataCssProperty extends HtmlDataMember {
    type?: string;
}
interface HtmlDataCssPart extends HtmlDataMember {
}
interface HtmlDataTag {
    name: string;
    description?: string;
    jsDoc?: string;
    attributes?: HtmlDataAttribute[];
    properties?: HtmlDataProperty[];
    slots?: HtmlDataSlot[];
    events?: HtmlDataEvent[];
    cssProperties?: HtmlDataCssProperty[];
    cssParts?: HtmlDataCssPart[];
}
interface HtmlDataV2 {
    version: 2;
    tags?: HtmlDataTag[];
    valueSets?: HtmlDataValueSet[];
    global?: {
        attributes?: HtmlDataMember[];
        properties?: HtmlDataMember[];
        slots?: HtmlDataMember[];
        events?: HtmlDataMember[];
    };
}
declare type HtmlData = HtmlDataV2;
interface HtmlDataAttrValue {
    name: string;
    description?: string;
}
interface HtmlDataAttr {
    name: string;
    description?: string;
    values?: HtmlDataAttrValue[];
    valueSet?: string;
}
interface HtmlDataTag_$0 {
    name: string;
    description?: string;
    attributes: HtmlDataAttr[];
}
interface HtmlDataValueSet_$0 {
    name: string;
    values: HtmlDataAttrValue[];
}
interface HtmlDataV1 {
    version: 1;
    tags?: HtmlDataTag_$0[];
    globalAttributes?: HtmlDataAttr[];
    valueSets?: HtmlDataValueSet_$0[];
}
declare type VscodeHtmlData = HtmlDataV1;
declare const VERSION = "0.1.20";
declare const DEFAULT_FLAVORS: AnalyzerFlavor[];
declare const DEFAULT_FEATURE_COLLECTION_CACHE: WeakMap<object, any>;
/**
 * Flattens an array.
 * @param array
 */
declare function arrayFlat<T>(array: T[][]): T[];
declare function arrayDefined<T>(array: (T | undefined)[]): T[];
declare function generateInheritanceTreeText(treeNode: InheritanceTreeNode): string;
declare function visiti2InheritanceTreeClause(treeClause: InheritanceTreeClause, nodes: Set<Node>): void;
declare function visit2InheritanceTreeNode(treeNode: InheritanceTreeNode, nodes: Set<Node>): void;
declare function getUniqueResolvedNodeForInheritanceTree(tree: InheritanceTreeNode): Set<Node>;
declare function executeFunctionsUntilMatch<T extends Partial<Record<K, any>>, K extends keyof T, ReturnValue extends ReturnType<NonNullable<T[K]>>, ArgType>(functionMaps: T[], keys: K | K[], arg: ArgType, context: AnalyzerVisitContext): {
    value: NonNullable<ReturnValue>;
    shouldContinue?: boolean;
} | undefined;
declare type VisitFeatureEmitMap = {
    [K in ComponentFeature]: (result: FeatureVisitReturnTypeMap[K][]) => void;
};
declare function visitFeatures<ReturnType>(node: Node, context: AnalyzerVisitContext, emitMap: Partial<VisitFeatureEmitMap>): void;
declare type RefineFeatureEmitMap = {
    [K in ComponentFeature]: (result: FeatureVisitReturnTypeMap[K]) => void;
};
declare function refineFeature_$0<FeatureKind extends ComponentFeature, ValueType = FeatureVisitReturnTypeMap[FeatureKind]>(featureKind: FeatureKind, value: ValueType | ValueType[], context: AnalyzerVisitContext, emitMap: Partial<RefineFeatureEmitMap>): void;
declare function mergeJsDocIntoJsDoc(leftJsDoc: JsDoc | undefined, rightJsDoc: JsDoc | undefined): JsDoc | undefined;
/**
 * Merges based on a name
 * @param entries
 * @param direction
 * @param getName
 * @param merge
 */
declare function mergeNamedEntries<T>(entries: T[], getName: (entry: T) => string, merge?: (left: T, right: T) => T): T[];
declare function mergeSlots(slots: ComponentSlot[]): ComponentSlot[];
declare function mergeCssParts(cssParts: ComponentCssPart[]): ComponentCssPart[];
declare function mergeCssProperties(cssProps: ComponentCssProperty[]): ComponentCssProperty[];
declare function mergeMethods(methods: ComponentMethod[]): ComponentMethod[];
declare function mergeEvents(events: ComponentEvent[]): ComponentEvent[];
declare function mergeMemberResults(memberResults: ComponentMemberResult[], context: AnalyzerVisitContext): ComponentMemberResult[];
declare function mergeFeatures(collection: ComponentFeatureCollection | ComponentFeatureCollection[], context: AnalyzerVisitContext): ComponentFeatureCollection;
declare function discoverFeatures_$0(node: Node, context: AnalyzerVisitContext): ComponentFeatureCollection;
declare function visitAndExpandInheritClause(inheritClause: InheritanceTreeClause, context: AnalyzerVisitContext): InheritanceTreeClause;
declare function visitInheritance(node: Node, context: AnalyzerVisitContext, emit: (results: InheritanceTreeClause[]) => void): void;
declare function discoverInheritance_$0(startNode: Node, context: AnalyzerVisitContext): InheritanceTreeNode;
declare function excludeNode_$0(node: Node, context: AnalyzerVisitContext): boolean;
declare function refineDeclaration_$0(declaration: ComponentDeclaration, context: AnalyzerVisitContext): ComponentDeclaration;
declare function analyzeComponentDeclaration(declarationNode: Node, context: AnalyzerVisitContext): ComponentDeclaration;
declare function visitDefinitions(node: Node, context: AnalyzerVisitContext, emit: (results: DefinitionNodeResult[]) => void): void;
/**
 * Visits the source file and finds all component definitions as "customElements.define".
 * Next it dedupes definitions and parses the corresponding component declaration for each definition.
 * @param sourceFile
 * @param context
 * @param analyzeDeclaration
 */
declare function discoverDefinitions_$0(sourceFile: SourceFile, context: AnalyzerVisitContext, analyzeDeclaration: (declarationNodes: Node[]) => ComponentDeclaration): ComponentDefinition[];
/**
 * Analyzes all components in a source file.
 * @param sourceFile
 * @param options
 */
declare function analyzeSourceFile(sourceFile: SourceFile, options: AnalyzerOptions): AnalyzerResult;
declare function stripTypescriptValues(input: any, checker: TypeChecker): any;
/**
 * Transforms results to json.
 * @param results
 * @param program
 * @param config
 */
declare const debugJsonTransformer: TransformerFunction;
declare function filterVisibility<T extends {
    visibility?: VisibilityKind;
}>(visibility: VisibilityKind, array: T[]): T[];
/**
 * Transforms results to json.
 * @param results
 * @param program
 * @param config
 */
declare const jsonTransformer: TransformerFunction;
/**
 * Returns a markdown header with a specific level taking global start title level into account.
 * @param title
 * @param level
 * @param config
 */
declare function markdownHeader(title: string, level: number, config: TransformerConfig): string;
/**
 * Returns a markdown table representation of the rows.
 * Strips unused columns.
 * @param rows
 * @param removeEmptyColumns
 */
declare function markdownTable(rows: string[][], { removeEmptyColumns }?: {
    removeEmptyColumns: boolean;
}): string;
/**
 * Escape a text so it can be used in a markdown table
 * @param text
 */
declare function markdownEscapeTableCell(text: string): string;
/**
 * Highlights some text
 * @param text
 */
declare function markdownHighlight(text: string | undefined): string;
/**
 * Creates padding around some text with a target width.
 * @param text
 * @param width
 * @param paddingStart
 */
declare function fillWidth(text: string, width: number, paddingStart: number): string;
/**
 * Transforms the component results to markdown
 * @param results
 * @param program
 * @param config
 */
declare const markdownTransformer: TransformerFunction;
/**
 * Vscode json output format transformer.
 * @param results
 * @param program
 * @param config
 */
declare const vscodeTransformer: TransformerFunction;
declare function transformAnalyzerResult(kind: TransformerKind, results: AnalyzerResult | AnalyzerResult[], program: Program, config: TransformerConfig): string;
export { AstContext, resolveDeclarations, isAliasSymbol, isNamePrivate, isMemberAndWritable, isNodeWritableMember, hasFlag, hasModifier, getMemberVisibilityFromNode, getInterfaceKeys, isPropertyRequired, isNodeInDeclarationFile, findParent, findChild, getNodeSourceFileLang, getLeadingCommentForNode, Context, resolveNodeValue, discoverDefinitions, lazy, getJsDoc, parseJsDocTypeExpression, getJsDocType, discoverEvents, discoverInheritance, relaxType, discoverMembers, discoverMethods, excludeNode, refineFeature, CustomElementFlavor, parseJsDocForNode, discoverFeatures, refineDeclaration, JsDocFlavor, JSXFlavor, dashToCamelCase, camelToDashCase, getLitElementPropertyDecorator, getLitElementPropertyDecoratorConfig, getLitPropertyOptions, parseLitPropertyOption, LitElementFlavor, AnalyzerConfig, AnalyzerVisitContext, JsDocTagParsed, JsDocTag, JsDoc, ComponentCssPart, ComponentCssProperty, VisibilityKind, ComponentEvent, LitElementPropertyConfig, ComponentMemberKind, ComponentMemberReflectKind, ComponentMemberBase, ComponentMemberProperty, ComponentMemberAttribute, ComponentMember, ComponentMethod, ComponentSlot, InheritanceTreeClause, InheritanceTreeNode, ComponentDeclaration, PriorityKind, DefinitionNodeResult, ComponentMemberResult, FeatureVisitReturnTypeMap, ComponentFeatureCollection, FeatureAnalyzeVisitMap, FeatureRefineVisitMap, AnalyzerFlavor, ComponentDefinition, AnalyzerOptions, AnalyzerResult, ModifierKind, TransformerConfig, TransformerKind, TransformerFunction, HtmlDataValue, HtmlDataValueSet, HtmlDataMember, HtmlDataAttribute, HtmlDataProperty, HtmlDataSlot, HtmlDataEvent, HtmlDataCssProperty, HtmlDataCssPart, HtmlDataTag, HtmlDataV2, HtmlData, HtmlDataAttrValue, HtmlDataAttr, HtmlDataV1, VscodeHtmlData, VERSION, DEFAULT_FLAVORS, DEFAULT_FEATURE_COLLECTION_CACHE, arrayFlat, arrayDefined, generateInheritanceTreeText, visiti2InheritanceTreeClause, visit2InheritanceTreeNode, getUniqueResolvedNodeForInheritanceTree, executeFunctionsUntilMatch, VisitFeatureEmitMap, visitFeatures, RefineFeatureEmitMap, mergeJsDocIntoJsDoc, mergeNamedEntries, mergeSlots, mergeCssParts, mergeCssProperties, mergeMethods, mergeEvents, mergeMemberResults, mergeFeatures, visitAndExpandInheritClause, visitInheritance, analyzeComponentDeclaration, visitDefinitions, ComponentFeature, ALL_COMPONENT_FEATURES, analyzeSourceFile, stripTypescriptValues, debugJsonTransformer, filterVisibility, jsonTransformer, markdownHeader, markdownTable, markdownEscapeTableCell, markdownHighlight, fillWidth, markdownTransformer, vscodeTransformer, transformAnalyzerResult };
//# sourceMappingURL=chunk-96aed7e6.d.ts.map