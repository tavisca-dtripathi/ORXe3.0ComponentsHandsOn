import * as tsModule from 'typescript';
import { SimpleTypeKind, toSimpleType, toTypeString, isAssignableToSimpleTypeKind, isSimpleType as isSimpleType$1 } from 'ts-simple-type';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/**
 * Resolves all relevant declarations of a specific node. Defaults to "interfaces and classes".
 * @param node
 * @param context
 */
function resolveDeclarations(node, context) {
    if (node == null)
        return [];
    var checker = context.checker, ts = context.ts;
    // Get the symbol
    var symbol = checker.getSymbolAtLocation(node);
    if (symbol == null)
        return [];
    // Resolve aliased symbols
    if (isAliasSymbol(symbol, ts)) {
        symbol = checker.getAliasedSymbol(symbol);
        if (symbol == null)
            return [];
    }
    // Filters all declarations
    var allDeclarations = symbol.getDeclarations() || [];
    var validDeclarations = allDeclarations.filter(function (declaration) { return !ts.isIdentifier(declaration); });
    if (validDeclarations.length > 0) {
        return validDeclarations;
    }
    else {
        var declaration = symbol.valueDeclaration;
        return declaration != null ? [declaration] : [];
    }
}
function isAliasSymbol(symbol, ts) {
    return (symbol.flags & ts.SymbolFlags.Alias) !== 0;
}
/**
 * Returns if a name is private (starts with "_" or "#");
 * @param name	 * @param name
 */
function isNamePrivate(name) {
    return name.startsWith("_") || name.startsWith("#");
}
/**
 * Returns if a node is not readable and static.
 * This function is used because modifiers have not been added to the output yet.
 * @param node
 * @param ts
 */
function isMemberAndWritable(node, ts) {
    return !hasModifier(node, ts.SyntaxKind.ReadonlyKeyword) && !hasModifier(node, ts.SyntaxKind.StaticKeyword);
}
/**
 * Returns if a node is public looking at its modifiers.
 * @param node
 * @param ts
 */
function isNodeWritableMember(node, ts) {
    return !hasModifier(node, ts.SyntaxKind.ReadonlyKeyword) && !hasModifier(node, ts.SyntaxKind.StaticKeyword);
}
/**
 * Returns if a node has a specific modifier.
 * @param node
 * @param modifierKind
 */
function hasModifier(node, modifierKind) {
    if (node.modifiers == null)
        return false;
    return (node.modifiers || []).find(function (modifier) { return modifier.kind === modifierKind; }) != null;
}
/**
 * Returns the visibility of a node
 * @param node	 * @param node
 * @param ts	 * @param ts
 */
function getMemberVisibilityFromNode(node, ts) {
    if (hasModifier(node, ts.SyntaxKind.PrivateKeyword) || ("name" in node && ts.isIdentifier(node.name) && isNamePrivate(node.name.text))) {
        return "private";
    }
    else if (hasModifier(node, ts.SyntaxKind.ProtectedKeyword)) {
        return "protected";
    }
    else if (getNodeSourceFileLang(node) === "ts") {
        return "public";
    }
    return undefined;
}
/**
 * Returns all keys and corresponding interface/class declarations for keys in an interface.
 * @param interfaceDeclaration
 * @param ts
 * @param checker
 */
function getInterfaceKeys(interfaceDeclaration, _a) {
    var e_1, _b;
    var ts = _a.ts, checker = _a.checker;
    var extensions = [];
    try {
        for (var _c = __values(interfaceDeclaration.members), _d = _c.next(); !_d.done; _d = _c.next()) {
            var member = _d.value;
            // { "my-button": MyButton; }
            if (ts.isPropertySignature(member) && member.type != null) {
                var keyNode = member.name;
                var key = void 0;
                if (ts.isStringLiteral(keyNode)) {
                    key = keyNode.text;
                }
                else if (ts.isIdentifier(keyNode)) {
                    key = keyNode.getText();
                }
                else {
                    continue;
                }
                var declaration = void 0, identifier = void 0;
                if (ts.isTypeReferenceNode(member.type)) {
                    // { ____: MyButton; } or { ____: namespace.MyButton; }
                    identifier = member.type.typeName;
                    declaration = resolveDeclarations(identifier, { checker: checker, ts: ts })[0];
                }
                else if (ts.isTypeLiteralNode(member.type)) {
                    identifier = undefined;
                    declaration = member.type;
                }
                else {
                    continue;
                }
                if (declaration != null) {
                    extensions.push({ key: key, keyNode: keyNode, declaration: declaration, identifier: identifier });
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return extensions;
}
/**
 * Find a node recursively walking down the children of the tree. Depth first search.
 * @param node
 * @param test
 */
function findChild(node, test) {
    if (!node)
        return;
    if (test(node))
        return node;
    return node.forEachChild(function (child) { return findChild(child, test); });
}
function getNodeSourceFileLang(node) {
    return node.getSourceFile().fileName.endsWith("ts") ? "ts" : "js";
}
function getLeadingCommentForNode(node, ts) {
    var sourceFileText = node.getSourceFile().text;
    var leadingComments = ts.getLeadingCommentRanges(sourceFileText, node.pos);
    if (leadingComments != null && leadingComments.length > 0) {
        return sourceFileText.substring(leadingComments[0].pos, leadingComments[0].end);
    }
    return undefined;
}

/**
 * Takes a node and tries to resolve a constant value from it.
 * Returns undefined if no constant value can be resolved.
 * @param node
 * @param context
 */
function resolveNodeValue(node, context) {
    var e_1, _a;
    if (node == null)
        return undefined;
    var ts = context.ts, checker = context.checker;
    var depth = (context.depth || 0) + 1;
    // Always break when depth is larger than 10.
    // This ensures we cannot run into infinite recursion.
    if (depth > 10)
        return undefined;
    if (ts.isStringLiteralLike(node)) {
        return { value: node.text, node: node };
    }
    else if (ts.isNumericLiteral(node)) {
        return { value: Number(node.text), node: node };
    }
    else if (ts.isObjectLiteralExpression(node)) {
        try {
            // Try to parse object literal expressions as JSON by converting it to something parsable
            var regex = /([a-zA-Z1-9]*?):/gm;
            var json = node.getText().replace(regex, function (m) { return "\"" + m[0] + "\":"; });
            return { value: JSON.parse(json), node: node };
        }
        catch (_b) {
            // If something crashes it probably means that the object is more complex.
            // Therefore do nothing
        }
    }
    else if (node.kind === ts.SyntaxKind.TrueKeyword) {
        return { value: true, node: node };
    }
    else if (node.kind === ts.SyntaxKind.FalseKeyword) {
        return { value: false, node: node };
    }
    else if (node.kind === ts.SyntaxKind.NullKeyword) {
        return { value: null, node: node };
    }
    else if (node.kind === ts.SyntaxKind.UndefinedKeyword) {
        return { value: undefined, node: node };
    }
    // Resolve initializers for variable declarations
    if (ts.isVariableDeclaration(node)) {
        return resolveNodeValue(node.initializer, __assign(__assign({}, context), { depth: depth }));
    }
    // Resolve value of a property access expression. For example: MyEnum.RED
    else if (ts.isPropertyAccessExpression(node)) {
        return resolveNodeValue(node.name, __assign(__assign({}, context), { depth: depth }));
    }
    // Resolve initializer value of enum members.
    else if (ts.isEnumMember(node)) {
        if (node.initializer != null) {
            return resolveNodeValue(node.initializer, __assign(__assign({}, context), { depth: depth }));
        }
        else {
            return { value: node.parent.name.text + "." + node.name.getText(), node: node };
        }
    }
    // Resolve values of variables.
    else if (ts.isIdentifier(node) && checker != null) {
        var declaration = resolveDeclarations(node, { checker: checker, ts: ts }).filter(function (decl) { return ts.isVariableDeclaration(decl); });
        return resolveNodeValue(declaration[0], __assign(__assign({}, context), { depth: depth }));
    }
    // Fallthrough
    //  - "my-value" as string
    //  - <any>"my-value"
    //  - ("my-value")
    else if (ts.isAsExpression(node) || ts.isTypeAssertion(node) || ts.isParenthesizedExpression(node)) {
        return resolveNodeValue(node.expression, __assign(__assign({}, context), { depth: depth }));
    }
    // static get is() {
    //    return "my-element";
    // }
    else if (ts.isGetAccessor(node) && node.body != null) {
        try {
            for (var _c = __values(node.body.statements), _d = _c.next(); !_d.done; _d = _c.next()) {
                var stm = _d.value;
                if (ts.isReturnStatement(stm)) {
                    return resolveNodeValue(stm.expression, __assign(__assign({}, context), { depth: depth }));
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    return undefined;
}

/**
 * Visits custom element component definitions.
 * @param node
 * @param context
 */
function discoverDefinitions(node, _a) {
    var ts = _a.ts, checker = _a.checker;
    // customElements.define("my-element", MyElement)
    if (ts.isCallExpression(node)) {
        if (ts.isPropertyAccessExpression(node.expression)) {
            var leftExpression = node.expression.expression;
            if (ts.isPropertyAccessExpression(leftExpression) &&
                ts.isIdentifier(leftExpression.expression) &&
                leftExpression.expression.escapedText === "window") {
                leftExpression = leftExpression.name;
            }
            if (ts.isIdentifier(leftExpression) &&
                leftExpression.escapedText === "customElements" &&
                node.expression.name != null &&
                ts.isIdentifier(node.expression.name)) {
                // define("my-element", MyElement)
                if (node.expression.name.escapedText === "define") {
                    var _b = __read(node.arguments, 2), unresolvedTagNameNode = _b[0], identifierNode_1 = _b[1];
                    // ("my-element", MyElement)
                    var resolvedTagNameNode = resolveNodeValue(unresolvedTagNameNode, { ts: ts, checker: checker });
                    if (resolvedTagNameNode != null && identifierNode_1 != null && typeof resolvedTagNameNode.value === "string") {
                        var tagName_1 = resolvedTagNameNode.value;
                        var tagNameNode_1 = resolvedTagNameNode.node;
                        // (___, MyElement)
                        if (ts.isIdentifier(identifierNode_1)) {
                            var declarationNodes = resolveDeclarations(identifierNode_1, { checker: checker, ts: ts });
                            return declarationNodes.map(function (declarationNode) { return ({
                                tagName: tagName_1,
                                identifierNode: identifierNode_1,
                                tagNameNode: tagNameNode_1,
                                declarationNode: declarationNode
                            }); });
                        }
                        // (___, class { ... })
                        else if (ts.isClassLike(identifierNode_1) || ts.isInterfaceDeclaration(identifierNode_1)) {
                            return [
                                {
                                    tagName: tagName_1,
                                    tagNameNode: tagNameNode_1,
                                    declarationNode: identifierNode_1
                                }
                            ];
                        }
                    }
                }
            }
        }
        return undefined;
    }
    // interface HTMLElementTagNameMap { "my-button": MyButton; }
    if (ts.isInterfaceDeclaration(node) && ["HTMLElementTagNameMap", "ElementTagNameMap"].includes(node.name.text)) {
        var extensions = getInterfaceKeys(node, { ts: ts, checker: checker });
        return extensions.map(function (_a) {
            var key = _a.key, keyNode = _a.keyNode, identifier = _a.identifier, declaration = _a.declaration;
            return ({
                tagName: key,
                tagNameNode: keyNode,
                identifierNode: identifier,
                declarationNode: declaration
            });
        });
    }
    return undefined;
}

var NOTHING = Symbol();
function lazy(callback) {
    var value = NOTHING;
    return function () {
        if (value === NOTHING) {
            value = callback();
        }
        return value;
    };
}

function getJSDocNode(node, ts) {
    var _a, _b, _c;
    var parent = (_b = (_a = ts.getJSDocTags(node)) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.parent;
    if (parent != null && ts.isJSDoc(parent)) {
        return parent;
    }
    return (_c = node.jsDoc) === null || _c === void 0 ? void 0 : _c.find(function (n) { return ts.isJSDoc(n); });
}
function getJsDoc(node, tagNamesOrTs, ts) {
    // Overloaded case
    var tagNames = null;
    if (ts == null) {
        ts = tagNamesOrTs;
    }
    else {
        tagNames = tagNamesOrTs;
    }
    var jsDocNode = getJSDocNode(node, ts);
    if (jsDocNode == null) {
        var leadingComment = getLeadingCommentForNode(node, ts);
        if (leadingComment != null) {
            return parseJsDocString(leadingComment);
        }
        return undefined;
    }
    return {
        description: jsDocNode.comment == null ? undefined : String(jsDocNode.comment),
        node: jsDocNode,
        tags: jsDocNode.tags == null
            ? []
            : jsDocNode.tags
                .map(function (node) {
                var tag = String(node.tagName.escapedText);
                if (tagNames != null && tagNames.length > 0 && !tagNames.includes(tag.toLowerCase())) {
                    return undefined;
                }
                return {
                    node: node,
                    tag: tag,
                    comment: node.comment,
                    // Parse the jsdoc tag comment. Typescript strips descriptions on @type, so in that case, use "node.getText()"
                    parsed: lazy(function () { return parseJsDocTagString(tag === "type" ? node.getText() : "@" + tag + " " + (node.comment || "")); })
                };
            })
                .filter(function (tag) { return tag != null; })
    };
}
/**
 * Converts a given string to a SimpleType
 * Defaults to ANY
 * See http://usejsdoc.org/tags-type.html
 * @param str
 */
function parseJsDocTypeExpression(str) {
    // Fail safe if "str" is somehow undefined
    if (str == null) {
        return { kind: SimpleTypeKind.ANY };
    }
    // Parse normal types
    switch (str.toLowerCase()) {
        case "undefined":
            return { kind: SimpleTypeKind.UNDEFINED };
        case "null":
            return { kind: SimpleTypeKind.NULL };
        case "string":
            return { kind: SimpleTypeKind.STRING };
        case "number":
            return { kind: SimpleTypeKind.NUMBER };
        case "boolean":
            return { kind: SimpleTypeKind.BOOLEAN };
        case "array":
            return { kind: SimpleTypeKind.ARRAY, type: { kind: SimpleTypeKind.ANY } };
        case "object":
            return { kind: SimpleTypeKind.OBJECT, members: [] };
        case "any":
        case "*":
            return { kind: SimpleTypeKind.ANY };
    }
    // Match
    //  {  string  }
    if (str.startsWith(" ") || str.endsWith(" ")) {
        return parseJsDocTypeExpression(str.trim());
    }
    // Match:
    //   {string|number}
    if (str.includes("|")) {
        return {
            kind: SimpleTypeKind.UNION,
            types: str.split("|").map(function (str) {
                var childType = parseJsDocTypeExpression(str);
                // Convert ANY types to string literals so that {on|off} is "on"|"off" and not ANY|ANY
                if (childType.kind === SimpleTypeKind.ANY) {
                    return {
                        kind: SimpleTypeKind.STRING_LITERAL,
                        value: str
                    };
                }
                return childType;
            })
        };
    }
    // Match:
    //  {?number}       (nullable)
    //  {!number}       (not nullable)
    //  {...number}     (array of)
    var prefixMatch = str.match(/^(\?|!|(\.\.\.))(.+)$/);
    if (prefixMatch != null) {
        var modifier = prefixMatch[1];
        var type = parseJsDocTypeExpression(prefixMatch[3]);
        switch (modifier) {
            case "?":
                return {
                    kind: SimpleTypeKind.UNION,
                    types: [
                        {
                            kind: SimpleTypeKind.NULL
                        },
                        type
                    ]
                };
            case "!":
                return type;
            case "...":
                return {
                    kind: SimpleTypeKind.ARRAY,
                    type: type
                };
        }
    }
    // Match:
    //  {(......)}
    var parenMatch = str.match(/^\((.+)\)$/);
    if (parenMatch != null) {
        return parseJsDocTypeExpression(parenMatch[1]);
    }
    // Match
    //   {"red"}
    var stringLiteralMatch = str.match(/^["'](.+)["']$/);
    if (stringLiteralMatch != null) {
        return {
            kind: SimpleTypeKind.STRING_LITERAL,
            value: stringLiteralMatch[1]
        };
    }
    // Match
    //   {[number]}
    var arrayMatch = str.match(/^\[(.+)\]$/);
    if (arrayMatch != null) {
        return {
            kind: SimpleTypeKind.ARRAY,
            type: parseJsDocTypeExpression(arrayMatch[1])
        };
    }
    return { kind: SimpleTypeKind.ANY };
}
/**
 * Finds a @type jsdoc tag in the jsdoc and returns the corresponding simple type
 * @param jsDoc
 */
function getJsDocType(jsDoc) {
    var _a;
    if (jsDoc.tags != null) {
        var typeJsDocTag = jsDoc.tags.find(function (t) { return t.tag === "type"; });
        if (typeJsDocTag != null) {
            // We get the text of the node because typescript strips the type jsdoc tag under certain circumstances
            var parsedJsDoc = parseJsDocTagString(((_a = typeJsDocTag.node) === null || _a === void 0 ? void 0 : _a.getText()) || "");
            if (parsedJsDoc.type != null) {
                return parseJsDocTypeExpression(parsedJsDoc.type);
            }
        }
    }
}
/**
 * Parses "@tag {type} name description"
 * @param str
 */
function parseJsDocTagString(str) {
    var jsDocTag = {
        tag: ""
    };
    if (str[0] !== "@") {
        return jsDocTag;
    }
    var moveStr = function (byLength) {
        str = str.substring(typeof byLength === "number" ? byLength : byLength.length);
    };
    var unqouteStr = function (quotedStr) {
        return quotedStr.replace(/^['"](.+)["']$/, function (_, match) { return match; });
    };
    // Match tag
    var tagResult = str.match(/^(\s*@([\S-]+))/);
    if (tagResult == null) {
        return jsDocTag;
    }
    else {
        moveStr(tagResult[1]);
        jsDocTag.tag = tagResult[2];
    }
    // Match type
    var typeResult = str.match(/^(\s*\{([\s\S]*)\})/);
    if (typeResult != null) {
        moveStr(typeResult[1]);
        jsDocTag.type = typeResult[2];
    }
    // Match optional name
    var defaultNameResult = str.match(/^(\s*\[([\s\S]+)\])/);
    if (defaultNameResult != null) {
        moveStr(defaultNameResult[1]);
        var parts = defaultNameResult[2].split("=");
        if (parts.length === 2) {
            jsDocTag.name = unqouteStr(parts[0]);
            jsDocTag.default = parts[1];
            jsDocTag.optional = true;
        }
        else if (parts.length !== 0) {
            jsDocTag.name = unqouteStr(parts[0]);
        }
    }
    else {
        // Match required name
        var nameResult = str.match(/^(\s*(\S+))((\s*- [\s\S]+)|\s*)$/);
        if (nameResult != null) {
            moveStr(nameResult[1]);
            jsDocTag.name = unqouteStr(nameResult[2]);
        }
    }
    // Match comment
    if (str.length > 0) {
        jsDocTag.description = str.replace(/^\s*-\s*/, "").trim();
    }
    return jsDocTag;
}
function parseJsDocString(doc) {
    var e_1, _a;
    var lines = doc.split("\n").map(function (line) { return line.trim(); });
    var description = "";
    var readDescription = true;
    var currentTag = "";
    var tags = [];
    var commitCurrentTag = function () {
        if (currentTag.length > 0) {
            var tagToCommit_1 = currentTag;
            var tagMatch = tagToCommit_1.match(/^@(\S+)\s*/);
            if (tagMatch != null) {
                tags.push({
                    parsed: lazy(function () { return parseJsDocTagString(tagToCommit_1); }),
                    node: undefined,
                    tag: tagMatch[1],
                    comment: tagToCommit_1.substr(tagMatch[0].length)
                });
            }
            currentTag = "";
        }
    };
    try {
        for (var lines_1 = __values(lines), lines_1_1 = lines_1.next(); !lines_1_1.done; lines_1_1 = lines_1.next()) {
            var line = lines_1_1.value;
            if (line.match(/\*\//)) {
                continue;
            }
            var tagCommentMatch = line.match(/(^\s*\*\s*)@\s*/);
            if (tagCommentMatch != null) {
                commitCurrentTag();
                currentTag += line.substr(tagCommentMatch[1].length);
                readDescription = false;
            }
            else if (!readDescription) {
                var commentMatch = line.match(/^\s*\*\s*/);
                if (commentMatch != null) {
                    currentTag += "\n" + line.substr(commentMatch[0].length);
                }
            }
            else {
                var startLineMatch = line.match(/^\s*\/\*\*/);
                if (startLineMatch != null) {
                    description += line.substr(startLineMatch[0].length);
                }
                var commentMatch = line.match(/^\s*\*\s*/);
                if (commentMatch != null) {
                    if (description.length > 0) {
                        description += "\n";
                    }
                    description += line.substr(commentMatch[0].length);
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (lines_1_1 && !lines_1_1.done && (_a = lines_1.return)) _a.call(lines_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    commitCurrentTag();
    if (description.length === 0 && tags.length === 0) {
        return undefined;
    }
    return {
        description: description,
        tags: tags
    };
}

function discoverEvents(node, context) {
    var ts = context.ts, checker = context.checker;
    // new CustomEvent("my-event");
    if (ts.isNewExpression(node)) {
        var expression = node.expression, args = node.arguments, typeArguments_1 = node.typeArguments;
        if (expression.getText() === "CustomEvent" && args && args.length >= 1) {
            var arg = args[0];
            if (ts.isStringLiteralLike(arg)) {
                var eventName = arg.text;
                // Either grab jsdoc from the new expression or from a possible call expression that its wrapped in
                var jsDoc = getJsDoc(expression, ts) ||
                    (ts.isCallLikeExpression(node.parent) && getJsDoc(node.parent.parent, ts)) ||
                    (ts.isExpressionStatement(node.parent) && getJsDoc(node.parent, ts)) ||
                    undefined;
                return [
                    {
                        jsDoc: jsDoc,
                        name: eventName,
                        node: node,
                        type: lazy(function () {
                            var _a;
                            return ((((_a = typeArguments_1) === null || _a === void 0 ? void 0 : _a[0]) != null && checker.getTypeFromTypeNode(typeArguments_1[0])) ||
                                {
                                    kind: SimpleTypeKind.ANY
                                });
                        })
                    }
                ];
            }
        }
    }
    return undefined;
}

function discoverInheritance(node, context) {
    if (node == null)
        return;
    if (context.ts.isClassLike(node) || context.ts.isInterfaceDeclaration(node)) {
        // Visit inherited nodes
        var clauses_1 = [];
        resolveHeritageClauses(node, __assign(__assign({}, context), { emitHeritageClause: function (clause) { return clauses_1.push(clause); } }));
        return clauses_1;
    }
    return undefined;
}
/**
 * Visits and emit declaration members in each interface/class-like inherited node.
 * @param node
 * @param context
 */
function resolveHeritageClauses(node, context) {
    var e_1, _a, e_2, _b;
    if (node.heritageClauses != null) {
        try {
            for (var _c = __values(node.heritageClauses || []), _d = _c.next(); !_d.done; _d = _c.next()) {
                var heritage = _d.value;
                try {
                    for (var _e = (e_2 = void 0, __values(heritage.types)), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var type = _f.value;
                        resolveHeritageClause(heritage, type.expression, context);
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        // class Test implements MyBase
        // Don't visit interfaces if we are looking at a class, because the class already declares all things from the interface
        /*if (ts.isClassLike(node) && heritage.token === ts.SyntaxKind.ImplementsKeyword) {
                for (const type of heritage.types) {
                    //console.log("context.emitInheritNode(", type.expression);
                    //console.log("context.emitInherit(", type.expression.getText());
                    //context.emitInheritanceNode(type.expression);
                    //context.emitInheritanceIdentifier(type.expression);
                    if (ts.isIdentifier(type.expression)) {
                        emit({
                            kind: "interface",
                            identifier: type.expression
                        });
                    }
                }
                continue;
            }*/
        // [extends|implements] MyBase
    }
}
function resolveHeritageClause(heritage, node, context) {
    var e_3, _a, e_4, _b;
    var _c, _d, _e, _f;
    var ts = context.ts;
    if (ts.isCallExpression(node)) {
        // Mixins
        var identifier = node.expression, args = node.arguments;
        // Extend classes given to the mixin
        // Example: class MyElement extends MyMixin(MyBase) --> MyBase
        // Example: class MyElement extends MyMixin(MyBase1, MyBase2) --> MyBase1, MyBase2
        var horizontalInheritance_1 = [];
        try {
            for (var args_1 = __values(args), args_1_1 = args_1.next(); !args_1_1.done; args_1_1 = args_1.next()) {
                var arg = args_1_1.value;
                resolveHeritageClause(heritage, arg, __assign(__assign({}, context), { emitHeritageClause: function (clause) { return horizontalInheritance_1.push(clause); } }));
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (args_1_1 && !args_1_1.done && (_a = args_1.return)) _a.call(args_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
        // Resolve and traverse the mixin function
        // Example: class MyElement extends MyMixin(MyBase) --> MyMixin
        if (identifier != null && ts.isIdentifier(identifier)) {
            var declarations = resolveDeclarations(identifier, context);
            //const resolved: InheritanceTreeNode[] = arrayDefined(declarations.map(declaration => resolveMixin(declaration, context)));
            var resolved = [];
            try {
                for (var declarations_1 = __values(declarations), declarations_1_1 = declarations_1.next(); !declarations_1_1.done; declarations_1_1 = declarations_1.next()) {
                    var declaration = declarations_1_1.value;
                    // Extend right away if the node is a class declaration
                    if (context.ts.isClassLike(declaration)) {
                        //extendWithDeclarationNode(declaration, context);
                        resolved.push({ node: declaration, identifier: declaration.name });
                        continue;
                    }
                    // Else find the first class declaration in the block
                    // Note that we don't look for a return statement because this would complicate things
                    var clzDecl = findChild(declaration, context.ts.isClassLike);
                    if (clzDecl != null) {
                        //extendWithDeclarationNode(clzDecl, context);
                        resolved.push({ node: clzDecl, identifier: clzDecl.name });
                        continue;
                    }
                    // If we didn't find any class declarations, we might be in a function that wraps a mixin
                    // Therefore find the return statement and call this method recursively
                    var returnNode = findChild(declaration, context.ts.isReturnStatement);
                    if (returnNode != null && returnNode.expression != null && returnNode.expression !== node) {
                        resolveHeritageClause(heritage, returnNode.expression, __assign(__assign({}, context), { emitHeritageClause: function (clause) {
                                horizontalInheritance_1.push(clause);
                            } }));
                        continue;
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (declarations_1_1 && !declarations_1_1.done && (_b = declarations_1.return)) _b.call(declarations_1);
                }
                finally { if (e_4) throw e_4.error; }
            }
            (_d = (_c = context).emitHeritageClause) === null || _d === void 0 ? void 0 : _d.call(_c, {
                kind: "mixin",
                identifier: identifier,
                horizontalInherits: horizontalInheritance_1,
                resolved: resolved
            });
        }
    }
    else if (ts.isIdentifier(node)) {
        var declarations = resolveDeclarations(node, context);
        // Visit component declarations for each inherited node.
        var resolved = declarations.map(function (declaration) { return ({
            node: declaration,
            identifier: ts.isClassLike(declaration) || ts.isInterfaceDeclaration(declaration) ? declaration.name : undefined
        }); });
        //extendWithDeclarationNode(declaration, context);
        (_f = (_e = context).emitHeritageClause) === null || _f === void 0 ? void 0 : _f.call(_e, {
            kind: heritage.token === ts.SyntaxKind.ImplementsKeyword || ts.isInterfaceDeclaration(heritage.parent) ? "interface" : "class",
            identifier: node,
            resolved: resolved
        });
    }
    return undefined;
}

/**
 * Relax the type so that for example "string literal" become "string" and "function" become "any"
 * This is used for javascript files to provide type checking with Typescript type inferring
 * @param type
 */
function relaxType(type) {
    switch (type.kind) {
        case SimpleTypeKind.INTERSECTION:
        case SimpleTypeKind.UNION:
            return __assign(__assign({}, type), { types: type.types.map(function (t) { return relaxType(t); }) });
        case SimpleTypeKind.ENUM:
            return __assign(__assign({}, type), { types: type.types.map(function (t) { return relaxType(t); }) });
        case SimpleTypeKind.ARRAY:
            return __assign(__assign({}, type), { type: relaxType(type.type) });
        case SimpleTypeKind.PROMISE:
            return __assign(__assign({}, type), { type: relaxType(type.type) });
        case SimpleTypeKind.OBJECT:
            return {
                name: type.name,
                kind: SimpleTypeKind.OBJECT
            };
        case SimpleTypeKind.INTERFACE:
        case SimpleTypeKind.FUNCTION:
        case SimpleTypeKind.CLASS:
            return {
                name: type.name,
                kind: SimpleTypeKind.ANY
            };
        case SimpleTypeKind.NUMBER_LITERAL:
            return { kind: SimpleTypeKind.NUMBER };
        case SimpleTypeKind.STRING_LITERAL:
            return { kind: SimpleTypeKind.STRING };
        case SimpleTypeKind.BOOLEAN_LITERAL:
            return { kind: SimpleTypeKind.BOOLEAN };
        case SimpleTypeKind.BIG_INT_LITERAL:
            return { kind: SimpleTypeKind.BIG_INT };
        case SimpleTypeKind.ENUM_MEMBER:
            return __assign(__assign({}, type), { type: relaxType(type.type) });
        case SimpleTypeKind.ALIAS:
            return __assign(__assign({}, type), { target: relaxType(type.target) });
        case SimpleTypeKind.NULL:
        case SimpleTypeKind.UNDEFINED:
            return { kind: SimpleTypeKind.ANY };
        default:
            return type;
    }
}

function discoverMembers(node, context) {
    var e_1, _a, e_2, _b;
    var _c, _d;
    var ts = context.ts, checker = context.checker;
    // static get observedAttributes() { return ['c', 'l']; }
    if (ts.isGetAccessor(node) && hasModifier(node, ts.SyntaxKind.StaticKeyword)) {
        if (node.name.getText() === "observedAttributes" && node.body != null) {
            var members = [];
            var returnStatement = node.body.statements.find(function (statement) { return ts.isReturnStatement(statement); });
            if (returnStatement != null) {
                if (returnStatement.expression != null && ts.isArrayLiteralExpression(returnStatement.expression)) {
                    try {
                        // Emit an attribute for each string literal in the array.
                        for (var _e = __values(returnStatement.expression.elements), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var attrNameNode = _f.value;
                            var attrName = ts.isStringLiteralLike(attrNameNode) ? attrNameNode.text : undefined;
                            if (attrName == null)
                                continue;
                            members.push({
                                priority: "medium",
                                member: {
                                    node: attrNameNode,
                                    jsDoc: getJsDoc(attrNameNode, ts),
                                    kind: "attribute",
                                    attrName: attrName,
                                    type: undefined // () => ({ kind: SimpleTypeKind.ANY } as SimpleType),
                                }
                            });
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
            }
            return members;
        }
    }
    // class { myProp = "hello"; }
    else if ((ts.isPropertyDeclaration(node) || ts.isPropertySignature(node)) && isNodeWritableMember(node, ts)) {
        var name_1 = node.name, initializer = node.initializer;
        if (ts.isIdentifier(name_1) || ts.isStringLiteralLike(name_1)) {
            // Find default value based on initializer
            var def = "initializer" in node && node.initializer != null ? (_c = resolveNodeValue(initializer, context)) === null || _c === void 0 ? void 0 : _c.value : undefined;
            return [
                {
                    priority: "high",
                    member: {
                        node: node,
                        kind: "property",
                        jsDoc: getJsDoc(node, ts),
                        propName: name_1.text,
                        type: lazy(function () { return checker.getTypeAtLocation(node); }),
                        default: def,
                        visibility: getMemberVisibilityFromNode(node, ts)
                        //required: isPropertyRequired(node, context.checker),
                    }
                }
            ];
        }
    }
    // class { set myProp(value: string) { ... } }
    else if (ts.isSetAccessor(node) && isNodeWritableMember(node, ts)) {
        var name_2 = node.name, parameters = node.parameters;
        if (ts.isIdentifier(name_2) && parameters.length > 0) {
            var parameter_1 = parameters[0];
            return [
                {
                    priority: "high",
                    member: {
                        node: node,
                        jsDoc: getJsDoc(node, ts),
                        kind: "property",
                        propName: name_2.text,
                        type: lazy(function () { return context.checker.getTypeAtLocation(parameter_1); }),
                        visibility: getMemberVisibilityFromNode(node, ts)
                    }
                }
            ];
        }
    }
    // constructor { super(); this.title = "Hello"; }
    else if (ts.isConstructorDeclaration(node) && getNodeSourceFileLang(node) === "js") {
        if (node.body != null) {
            var assignments = node.body.statements
                .filter(function (stmt) { return ts.isExpressionStatement(stmt); })
                .map(function (stmt) { return stmt.expression; })
                .filter(function (exp) { return ts.isBinaryExpression(exp); });
            var members = [];
            var _loop_1 = function (assignment) {
                var left = assignment.left, right = assignment.right;
                if (ts.isPropertyAccessExpression(left)) {
                    if (left.expression.kind === ts.SyntaxKind.ThisKeyword) {
                        var propName = left.name.getText();
                        members.push({
                            priority: "low",
                            member: {
                                node: node,
                                kind: "property",
                                propName: propName,
                                default: (_d = resolveNodeValue(right, context)) === null || _d === void 0 ? void 0 : _d.value,
                                type: function () { return relaxType(toSimpleType(checker.getTypeAtLocation(right), checker)); },
                                jsDoc: getJsDoc(assignment.parent, ts),
                                visibility: isNamePrivate(propName) ? "private" : undefined
                            }
                        });
                    }
                }
            };
            try {
                for (var assignments_1 = __values(assignments), assignments_1_1 = assignments_1.next(); !assignments_1_1.done; assignments_1_1 = assignments_1.next()) {
                    var assignment = assignments_1_1.value;
                    _loop_1(assignment);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (assignments_1_1 && !assignments_1_1.done && (_b = assignments_1.return)) _b.call(assignments_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return members;
        }
    }
    return undefined;
}

function discoverMethods(node, context) {
    var _a, _b;
    var ts = context.ts;
    // class { myMethod () {} }
    if ((ts.isMethodDeclaration(node) || ts.isMethodSignature(node)) && isMemberAndWritable(node, ts)) {
        var name_1 = node.name.getText();
        if (isHTMLElementMethodName(name_1)) {
            return undefined;
        }
        // Allow the analyzer to analyze within methods
        (_b = (_a = context).emitContinue) === null || _b === void 0 ? void 0 : _b.call(_a);
        return [
            {
                jsDoc: getJsDoc(node, ts),
                name: name_1,
                node: node,
                visibility: getMemberVisibilityFromNode(node, ts)
            }
        ];
    }
    return undefined;
}
function isHTMLElementMethodName(name) {
    return ["attributeChangedCallback", "connectedCallback", "disconnectedCallback"].includes(name);
}

function excludeNode(node, context) {
    if (context.config.analyzeLibDom) {
        return undefined;
    }
    return node.getSourceFile().fileName.endsWith("lib.dom.d.ts");
}

var refineFeature = {
    member: function (memberResult, context) {
        var member = memberResult.member;
        if (member.visibility == null) {
            var name_1 = member.kind === "attribute" ? member.attrName : member.propName;
            if (isNamePrivate(name_1)) {
                return __assign(__assign({}, memberResult), { member: __assign(__assign({}, member), { visibility: "private" }) });
            }
        }
        return memberResult;
    }
};

var CustomElementFlavor = /** @class */ (function () {
    function CustomElementFlavor() {
        this.excludeNode = excludeNode;
        this.discoverDefinitions = discoverDefinitions;
        this.discoverFeatures = {
            member: discoverMembers,
            event: discoverEvents,
            method: discoverMethods
        };
        this.refineFeature = refineFeature;
        this.discoverInheritance = discoverInheritance;
    }
    return CustomElementFlavor;
}());

function parseJsDocForNode(node, tagNames, transform, context) {
    var _a, _b;
    var tags = (getJsDoc(node, tagNames, context.ts) || {}).tags;
    if (tags != null && tags.length > 0) {
        (_b = (_a = context).emitContinue) === null || _b === void 0 ? void 0 : _b.call(_a);
        return tags.map(function (tag) { return transform(tag.node, tag.parsed()); }).filter(function (item) { return item != null; });
    }
    return undefined;
}

function discoverDefinitions$1(node, context) {
    // /** @customElement my-element */ myClass extends HTMLElement { ... }
    if (context.ts.isInterfaceDeclaration(node) || context.ts.isClassDeclaration(node)) {
        return parseJsDocForNode(node, ["customelement", "element"], function (tagNode, _a) {
            var name = _a.name;
            return {
                tagName: name || "",
                identifierNode: tagNode,
                declarationNode: node,
                definitionNode: tagNode
            };
        }, context);
    }
}

var discoverFeatures = {
    csspart: function (node, context) {
        if (context.ts.isInterfaceDeclaration(node) || context.ts.isClassDeclaration(node)) {
            return parseJsDocForNode(node, ["csspart"], function (tagNode, _a) {
                var name = _a.name, description = _a.description;
                if (name != null && name.length > 0) {
                    return {
                        name: name,
                        jsDoc: description != null ? { description: description } : undefined
                    };
                }
            }, context);
        }
    },
    cssproperty: function (node, context) {
        if (context.ts.isInterfaceDeclaration(node) || context.ts.isClassDeclaration(node)) {
            return parseJsDocForNode(node, ["cssprop", "cssproperty", "cssvar", "cssvariable"], function (tagNode, _a) {
                var name = _a.name, description = _a.description, type = _a.type;
                if (name != null && name.length > 0) {
                    return {
                        name: name,
                        jsDoc: description != null ? { description: description } : undefined,
                        type: type || undefined
                    };
                }
            }, context);
        }
    },
    event: function (node, context) {
        if (context.ts.isInterfaceDeclaration(node) || context.ts.isClassDeclaration(node)) {
            return parseJsDocForNode(node, ["event", "fires", "emits"], function (tagNode, _a) {
                var name = _a.name, description = _a.description, type = _a.type;
                if (name != null && name.length > 0 && tagNode != null) {
                    return {
                        name: name,
                        jsDoc: description != null ? { description: description } : undefined,
                        type: lazy(function () { return (type && parseJsDocTypeExpression(type)) || { kind: SimpleTypeKind.ANY }; }),
                        typeHint: type,
                        node: tagNode
                    };
                }
            }, context);
        }
    },
    slot: function (node, context) {
        if (context.ts.isInterfaceDeclaration(node) || context.ts.isClassDeclaration(node)) {
            return parseJsDocForNode(node, ["slot"], function (tagNode, _a) {
                var name = _a.name, type = _a.type, description = _a.description;
                // Grab the type from jsdoc and use it to find permitted tag names
                // Example: @slot {"div"|"span"} myslot
                var permittedTagNameType = type == null ? undefined : parseJsDocTypeExpression(type);
                var permittedTagNames = (function () {
                    if (permittedTagNameType == null) {
                        return undefined;
                    }
                    switch (permittedTagNameType.kind) {
                        case SimpleTypeKind.STRING_LITERAL:
                            return [permittedTagNameType.value];
                        case SimpleTypeKind.UNION:
                            return permittedTagNameType.types
                                .filter(function (type) { return type.kind === SimpleTypeKind.STRING_LITERAL; })
                                .map(function (type) { return type.value; });
                        default:
                            return undefined;
                    }
                })();
                return {
                    name: name,
                    jsDoc: description != null ? { description: description } : undefined,
                    permittedTagNames: permittedTagNames
                };
            }, context);
        }
    },
    member: function (node, context) {
        if (context.ts.isInterfaceDeclaration(node) || context.ts.isClassDeclaration(node)) {
            var properties = parseJsDocForNode(node, ["prop", "property"], function (tagNode, _a) {
                var name = _a.name, def = _a.default, type = _a.type, description = _a.description;
                if (name != null && name.length > 0) {
                    return {
                        kind: "property",
                        propName: name,
                        jsDoc: description != null ? { description: description } : undefined,
                        typeHint: type,
                        type: lazy(function () { return (type && parseJsDocTypeExpression(type)) || { kind: SimpleTypeKind.ANY }; }),
                        node: tagNode,
                        default: def,
                        visibility: undefined,
                        reflect: undefined,
                        required: undefined,
                        deprecated: undefined
                    };
                }
            }, context);
            var attributes = parseJsDocForNode(node, ["attr", "attribute"], function (tagNode, _a) {
                var name = _a.name, def = _a.default, type = _a.type, description = _a.description;
                if (name != null && name.length > 0) {
                    return {
                        kind: "attribute",
                        attrName: name,
                        jsDoc: description != null ? { description: description } : undefined,
                        type: lazy(function () { return (type && parseJsDocTypeExpression(type)) || { kind: SimpleTypeKind.ANY }; }),
                        typeHint: type,
                        node: tagNode,
                        default: def,
                        visibility: undefined,
                        reflect: undefined,
                        required: undefined,
                        deprecated: undefined
                    };
                }
            }, context);
            if (attributes != null || properties != null) {
                return __spread((attributes || []), (properties || [])).map(function (member) { return ({
                    priority: getNodeSourceFileLang(node) === "js" ? "high" : "medium",
                    member: member
                }); });
            }
            return undefined;
        }
    }
};

function refineDeclaration(declaration, context) {
    if (declaration.jsDoc == null || declaration.jsDoc.tags == null) {
        return undefined;
    }
    var deprecatedTag = declaration.jsDoc.tags.find(function (t) { return t.tag === "deprecated"; });
    if (deprecatedTag != null) {
        return __assign(__assign({}, declaration), { deprecated: deprecatedTag.comment || true });
    }
    return undefined;
}

var refineFeature$1 = {
    event: function (event) {
        if (event.jsDoc == null || event.jsDoc.tags == null)
            return event;
        return [applyJsDocDeprecated, applyJsDocVisibility].reduce(function (event, applyFunc) { return applyFunc(event, event.jsDoc); }, event);
    },
    method: function (method) {
        if (method.jsDoc == null || method.jsDoc.tags == null)
            return method;
        return [applyJsDocDeprecated, applyJsDocVisibility].reduce(function (method, applyFunc) { return applyFunc(method, method.jsDoc); }, method);
    },
    member: function (memberResult) {
        var member = memberResult.member;
        // Return right away if the member doesn't have jsdoc
        if (member.jsDoc == null || member.jsDoc.tags == null)
            return memberResult;
        var jsDoc = member.jsDoc;
        var newMember = [
            applyJsDocDeprecated,
            applyJsDocVisibility,
            applyJsDocAttribute,
            applyJsDocRequired,
            applyJsDocDefault,
            applyJsDocReflect,
            applyJsDocType
        ].reduce(function (member, applyFunc) { return applyFunc(member, jsDoc); }, member);
        // only member
        return {
            priority: memberResult.priority,
            member: newMember
        };
    }
};
function applyJsDocDeprecated(feature, jsDoc) {
    var _a;
    var deprecatedTag = (_a = jsDoc.tags) === null || _a === void 0 ? void 0 : _a.find(function (tag) { return tag.tag === "deprecated"; });
    if (deprecatedTag != null) {
        return __assign(__assign({}, feature), { deprecated: deprecatedTag.comment || true });
    }
    return feature;
}
function applyJsDocVisibility(feature, jsDoc) {
    var _a;
    var visibilityTag = (_a = jsDoc.tags) === null || _a === void 0 ? void 0 : _a.find(function (tag) { return ["public", "protected", "private", "package", "access"].includes(tag.tag); }); // member + method
    if (visibilityTag != null) {
        return __assign(__assign({}, feature), { visibility: (function () {
                switch (visibilityTag.tag) {
                    case "public":
                        return "public";
                    case "protected":
                        return "protected";
                    case "package":
                    case "private":
                        return "private";
                    case "access":
                        switch (visibilityTag.parsed().name) {
                            case "public":
                                return "public";
                            case "protected":
                                return "protected";
                            case "private":
                            case "package":
                                return "private";
                        }
                    default:
                        return undefined;
                }
            })() });
    }
    return feature;
}
function applyJsDocAttribute(feature, jsDoc) {
    var _a;
    var attributeTag = (_a = jsDoc.tags) === null || _a === void 0 ? void 0 : _a.find(function (tag) { return ["attr", "attribute"].includes(tag.tag); });
    if (attributeTag != null && feature.attrName == null) {
        return __assign(__assign({}, feature), { attrName: attributeTag.parsed().name || feature.propName });
    }
    return feature;
}
function applyJsDocRequired(feature, jsDoc) {
    var _a;
    var requiredTag = (_a = jsDoc.tags) === null || _a === void 0 ? void 0 : _a.find(function (tag) { return ["optional", "required"].includes(tag.tag); });
    if (requiredTag != null) {
        return __assign(__assign({}, feature), { required: requiredTag.tag === "required" });
    }
    return feature;
}
function applyJsDocDefault(feature, jsDoc) {
    var _a;
    var defaultTag = (_a = jsDoc.tags) === null || _a === void 0 ? void 0 : _a.find(function (tag) { return tag.tag === "default"; });
    if (defaultTag != null) {
        return __assign(__assign({}, feature), { default: defaultTag.comment });
    }
    return feature;
}
function applyJsDocReflect(feature, jsDoc) {
    var _a;
    var reflectTag = (_a = jsDoc.tags) === null || _a === void 0 ? void 0 : _a.find(function (tag) { return tag.tag === "reflect"; });
    if (reflectTag != null && feature.reflect == null) {
        return __assign(__assign({}, feature), { reflect: (function () {
                switch (reflectTag.comment) {
                    case "to-attribute":
                        return "to-attribute";
                    case "to-property":
                        return "to-property";
                    case "both":
                        return "both";
                    default:
                        return undefined;
                }
            })() });
    }
    return feature;
}
function applyJsDocType(feature, jsDoc) {
    var _a, _b;
    var typeTag = (_a = jsDoc.tags) === null || _a === void 0 ? void 0 : _a.find(function (tag) { return tag.tag === "type"; });
    if (typeTag != null && feature.typeHint == null) {
        var parsed_1 = typeTag.parsed();
        if (parsed_1.type != null && parsed_1.type.length > 0) {
            return __assign(__assign({}, feature), { typeHint: parsed_1.type, type: (_b = feature.type, (_b !== null && _b !== void 0 ? _b : lazy(function () { return parseJsDocTypeExpression(parsed_1.type || ""); }))) });
        }
    }
    return feature;
}

var JsDocFlavor = /** @class */ (function () {
    function JsDocFlavor() {
        this.discoverDefinitions = discoverDefinitions$1;
        this.discoverFeatures = discoverFeatures;
        this.refineFeature = refineFeature$1;
        this.refineDeclaration = refineDeclaration;
    }
    return JsDocFlavor;
}());

function discoverDefinitions$2(node, context) {
    var ts = context.ts;
    if (ts.isInterfaceDeclaration(node)) {
        if (node.name.text === "IntrinsicElements") {
            var extensions = getInterfaceKeys(node, context);
            return extensions.map(function (_a) {
                var key = _a.key, keyNode = _a.keyNode, identifier = _a.identifier, declaration = _a.declaration;
                return ({
                    tagName: key,
                    tagNameNode: keyNode,
                    identifierNode: identifier,
                    declarationNode: declaration
                });
            });
        }
    }
    return undefined;
}

var JSXFlavor = /** @class */ (function () {
    function JSXFlavor() {
        this.discoverDefinitions = discoverDefinitions$2;
        // TODO: Check JSX.IntrinsicAttributes interface when scanning for "global" properties/attributes
    }
    return JSXFlavor;
}());

/**
 * Visits lit-element related definitions.
 * Specifically it finds the usage of the @customElement decorator.
 * @param node
 * @param context
 */
function discoverDefinitions$3(node, context) {
    var e_1, _a;
    var ts = context.ts, checker = context.checker;
    // @customElement("my-element")
    if (ts.isClassDeclaration(node)) {
        try {
            for (var _b = __values(node.decorators || []), _c = _b.next(); !_c.done; _c = _b.next()) {
                var decorator = _c.value;
                var callExpression = decorator.expression;
                if (ts.isCallExpression(callExpression) && ts.isIdentifier(callExpression.expression)) {
                    var decoratorIdentifierName = callExpression.expression.escapedText;
                    if (decoratorIdentifierName === "customElement") {
                        // Resolve the value of the first argument. This is the tag name.
                        var unresolvedTagNameNode = callExpression.arguments[0];
                        var resolvedTagNameNode = resolveNodeValue(unresolvedTagNameNode, { ts: ts, checker: checker });
                        if (resolvedTagNameNode != null && typeof resolvedTagNameNode.value === "string") {
                            return [
                                {
                                    tagName: resolvedTagNameNode.value,
                                    tagNameNode: resolvedTagNameNode.node,
                                    declarationNode: node
                                }
                            ];
                        }
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return;
    }
    node.forEachChild(function (child) {
        discoverDefinitions$3(child, context);
    });
}

/**
 * Converts from snake case to camel case
 * @param str
 */
/**
 * Converts from camel case to snake case
 * @param str
 */
function camelToDashCase(str) {
    return str.replace(/[A-Z]/g, function (m) { return "-" + m.toLowerCase(); });
}

/**
 * Returns a potential lit element property decorator.
 * @param node
 * @param context
 */
function getLitElementPropertyDecorator(node, context) {
    if (node.decorators == null)
        return undefined;
    var ts = context.ts;
    // Find a decorator with "property" name.
    var decorator = node.decorators.find(function (decorator) {
        var expression = decorator.expression;
        return ts.isCallExpression(expression) && ts.isIdentifier(expression.expression) && expression.expression.text === "property";
    });
    return decorator != null && ts.isCallExpression(decorator.expression) ? decorator.expression : undefined;
}
/**
 * Returns a potential lit property decorator configuration.
 * @param node
 * @param context
 */
function getLitElementPropertyDecoratorConfig(node, context) {
    var ts = context.ts;
    // Get reference to a possible "@property" decorator.
    var decorator = getLitElementPropertyDecorator(node, context);
    if (decorator != null) {
        // Parse the first argument to the decorator which is the lit-property configuration.
        var configNode = decorator.arguments[0];
        return configNode != null && ts.isObjectLiteralExpression(configNode) ? getLitPropertyOptions(configNode, context) : {};
    }
    return undefined;
}
/**
 * Parses an object literal expression and returns a lit property configuration.
 * @param node
 * @param context
 */
function getLitPropertyOptions(node, context) {
    var ts = context.ts;
    // Build up the property configuration by looking at properties in the object literal expression
    return node.properties.reduce(function (config, property) {
        if (!ts.isPropertyAssignment(property))
            return config;
        var initializer = property.initializer;
        var kind = ts.isIdentifier(property.name) ? property.name.text : undefined;
        return parseLitPropertyOption({ kind: kind, initializer: initializer, config: config }, context);
    }, {});
}
function parseLitPropertyOption(_a, context) {
    var kind = _a.kind, initializer = _a.initializer, config = _a.config;
    var _b, _c;
    var ts = context.ts, checker = context.checker;
    // noinspection DuplicateCaseLabelJS
    switch (kind) {
        case "converter": {
            return __assign(__assign({}, config), { hasConverter: true });
        }
        case "reflect": {
            return __assign(__assign({}, config), { reflect: ((_b = resolveNodeValue(initializer, context)) === null || _b === void 0 ? void 0 : _b.value) === true });
        }
        case "attribute": {
            var attribute = void 0;
            if (initializer.kind === ts.SyntaxKind.TrueKeyword) {
                attribute = true;
            }
            else if (initializer.kind === ts.SyntaxKind.FalseKeyword) {
                attribute = false;
            }
            else if (ts.isStringLiteral(initializer)) {
                attribute = initializer.text;
            }
            return __assign(__assign({}, config), { attribute: attribute, node: __assign(__assign({}, (config.node || {})), { attribute: initializer }) });
        }
        case "type": {
            var type = void 0;
            var value = ts.isIdentifier(initializer) ? initializer.text : undefined;
            switch (value) {
                case "String":
                case "StringConstructor":
                    type = { kind: SimpleTypeKind.STRING };
                    break;
                case "Number":
                case "NumberConstructor":
                    type = { kind: SimpleTypeKind.NUMBER };
                    break;
                case "Boolean":
                case "BooleanConstructor":
                    type = { kind: SimpleTypeKind.BOOLEAN };
                    break;
                case "Array":
                case "ArrayConstructor":
                    type = { kind: SimpleTypeKind.ARRAY, type: { kind: SimpleTypeKind.ANY } };
                    break;
                case "Object":
                case "ObjectConstructor":
                    type = { kind: SimpleTypeKind.OBJECT, members: [] };
                    break;
                default:
                    // This is an unknown type, so set the name as a string
                    type = initializer.getText();
                    break;
            }
            return __assign(__assign({}, config), { type: type, node: __assign(__assign({}, (config.node || {})), { type: initializer }) });
        }
        // Polymer specific field
        case "value": {
            return __assign(__assign({}, config), { default: (_c = resolveNodeValue(initializer, { ts: ts, checker: checker })) === null || _c === void 0 ? void 0 : _c.value });
        }
    }
    return config;
}

/**
 * Parses lit-related declaration members.
 * This is primary by looking at the "@property" decorator and the "static get properties()".
 * @param node
 * @param context
 */
function discoverMembers$1(node, context) {
    var ts = context.ts;
    // static get properties() { return { myProp: {type: String} } }
    if (ts.isGetAccessor(node) && hasModifier(node, ts.SyntaxKind.StaticKeyword)) {
        var name_1 = node.name.getText();
        if (name_1 === "properties" && node.body != null) {
            var returnStatement = node.body.statements.find(ts.isReturnStatement.bind(ts));
            if (returnStatement != null) {
                return parseStaticProperties(returnStatement, context);
            }
        }
    }
    // @property({type: String}) myProp = "hello";
    else if ((ts.isSetAccessorDeclaration(node) || ts.isPropertyDeclaration(node) || ts.isPropertySignature(node)) && isNodeWritableMember(node, ts)) {
        return parsePropertyDecorator(node, context);
    }
}
/**
 * Visits a lit property decorator and returns members based on it.
 * @param node
 * @param context
 */
function parsePropertyDecorator(node, context) {
    var _a;
    var ts = context.ts, checker = context.checker;
    // Parse the content of a possible lit "@property" decorator.
    var litConfig = getLitElementPropertyDecoratorConfig(node, context);
    if (litConfig != null) {
        var propName = node.name.getText();
        // Don't emit anything if "attribute" is false.
        // "Custom Element Flavor" takes care of parsing the property then.
        if (litConfig.attribute === false) {
            return;
        }
        // Get the attribute based on the configuration
        var attrName = getLitAttributeName(propName, litConfig);
        // Find the default value for this property
        var def = "initializer" in node && node.initializer != null ? (_a = resolveNodeValue(node.initializer, context)) === null || _a === void 0 ? void 0 : _a.value : undefined;
        // Find our if the property/attribute is required
        //const required = ("initializer" in node && isPropertyRequired(node, context.checker)) || undefined;
        var required = undefined;
        var jsDoc = getJsDoc(node, ts);
        // Emit a property with "attrName"
        return [
            {
                priority: "high",
                member: {
                    kind: "property",
                    propName: propName,
                    attrName: attrName,
                    type: lazy(function () {
                        var propType = checker.getTypeAtLocation(node);
                        var inJavascriptFile = getNodeSourceFileLang(node) === "js";
                        return inJavascriptFile && typeof litConfig.type === "object" && litConfig.type.kind === SimpleTypeKind.ANY ? litConfig.type : propType;
                    }),
                    node: node,
                    default: def !== undefined ? def : litConfig.default,
                    required: required,
                    jsDoc: jsDoc,
                    meta: litConfig,
                    visibility: getMemberVisibilityFromNode(node, ts),
                    reflect: litConfig.reflect ? "both" : "to-property"
                }
            }
        ];
    }
    return undefined;
}
/**
 * Returns if we are in a Polymer context.
 * @param context
 */
function inPolymerFlavorContext(context) {
    //const inherits = context.features != null ? context.features.getInherits() : [];
    // TODO: check!
    var inherits = [];
    return inherits.includes("PolymerElement") || inherits.includes("Polymer.Element");
}
/**
 * Returns an attribute name based on a property name and a lit-configuration
 * @param propName
 * @param litConfig
 * @param context
 */
function getLitAttributeName(propName, litConfig, context) {
    // Get the attribute name either by looking at "{attribute: ...}" or just taking the property name.
    var attrName = typeof litConfig.attribute === "string" ? litConfig.attribute : propName;
    if (inPolymerFlavorContext()) {
        // From the documentation: https://polymer-library.polymer-project.org/3.0/docs/devguide/properties#attribute-reflection
        attrName = camelToDashCase(attrName).toLowerCase();
    }
    return attrName;
}
/**
 * Visits static properties
 * static get properties() { return { myProp: {type: String, attribute: "my-attr"} } }
 * @param returnStatement
 * @param context
 */
function parseStaticProperties(returnStatement, context) {
    var e_1, _a;
    var ts = context.ts;
    var memberResults = [];
    if (returnStatement.expression != null && ts.isObjectLiteralExpression(returnStatement.expression)) {
        var isPolymerFlavor = inPolymerFlavorContext();
        var _loop_1 = function (propNode) {
            // Get propName
            var propName = propNode.name != null && ts.isIdentifier(propNode.name) ? propNode.name.text : undefined;
            if (propName == null) {
                return "continue";
            }
            // Parse the lit property config for this property
            // Treat non-object-literal-expressions like the "type" (to support Polymer specific syntax)
            var litConfig = ts.isPropertyAssignment(propNode)
                ? ts.isObjectLiteralExpression(propNode.initializer)
                    ? getLitPropertyOptions(propNode.initializer, context)
                    : isPolymerFlavor
                        ? parseLitPropertyOption({
                            kind: "type",
                            initializer: propNode.initializer,
                            config: {}
                        }, context)
                        : {}
                : {};
            // Get attrName based on the litConfig
            var attrName = getLitAttributeName(propName, litConfig);
            // Get more metadata
            var jsDoc = getJsDoc(propNode, ts);
            var emitAttribute = litConfig.attribute !== false;
            // Emit either the attribute or the property
            memberResults.push({
                priority: "high",
                member: {
                    kind: "property",
                    type: lazy(function () {
                        return (jsDoc && getJsDocType(jsDoc)) || (typeof litConfig.type === "object" && litConfig.type) || { kind: SimpleTypeKind.ANY };
                    }),
                    propName: propName,
                    attrName: emitAttribute ? attrName : undefined,
                    jsDoc: jsDoc,
                    node: propNode,
                    meta: litConfig,
                    default: litConfig.default,
                    reflect: litConfig.reflect ? "both" : "to-property"
                }
            });
        };
        try {
            // Each property in the object literal expression corresponds to a class field.
            for (var _b = __values(returnStatement.expression.properties), _c = _b.next(); !_c.done; _c = _b.next()) {
                var propNode = _c.value;
                _loop_1(propNode);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    return memberResults;
}

function excludeNode$1(node, context) {
    if (context.config.analyzeLib) {
        return undefined;
    }
    var fileName = node.getSourceFile().fileName;
    return fileName.includes("lit-element.d.ts") || fileName.endsWith("updating-element.d.ts");
}

var LitElementFlavor = /** @class */ (function () {
    function LitElementFlavor() {
        this.excludeNode = excludeNode$1;
        this.discoverDefinitions = discoverDefinitions$3;
        this.discoverFeatures = {
            member: discoverMembers$1
        };
    }
    return LitElementFlavor;
}());

var VERSION = "0.1.20";
var DEFAULT_FLAVORS = [new LitElementFlavor(), new CustomElementFlavor(), new JsDocFlavor(), new JSXFlavor()];
var DEFAULT_FEATURE_COLLECTION_CACHE = new WeakMap();

/**
 * Flattens an array.
 * @param array
 */
function arrayFlat(array) {
    return "flat" in array ? array.flat() : array.reduce(function (acc, a) { return __spread(acc, a); }, []);
}

function visiti2InheritanceTreeClause(treeClause, nodes) {
    var _a, _b;
    (_a = treeClause.resolved) === null || _a === void 0 ? void 0 : _a.forEach(function (treeNode) { return visit2InheritanceTreeNode(treeNode, nodes); });
    (_b = treeClause.horizontalInherits) === null || _b === void 0 ? void 0 : _b.forEach(function (clause) { return visiti2InheritanceTreeClause(clause, nodes); });
}
function visit2InheritanceTreeNode(treeNode, nodes) {
    var _a;
    nodes.add(treeNode.node);
    (_a = treeNode.inherits) === null || _a === void 0 ? void 0 : _a.forEach(function (clause) { return visiti2InheritanceTreeClause(clause, nodes); });
}
function getUniqueResolvedNodeForInheritanceTree(tree) {
    var nodes = new Set();
    visit2InheritanceTreeNode(tree, nodes);
    return nodes;
}

function executeFunctionsUntilMatch(functionMaps, keys, arg, context) {
    var e_1, _a, e_2, _b;
    keys = Array.isArray(keys) ? keys : [keys];
    try {
        for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
            var key = keys_1_1.value;
            var _loop_1 = function (functionMap) {
                var func = functionMap[key];
                if (func == null)
                    return "continue";
                // Save a "continue" flag if necessary
                var shouldContinue = false;
                var result = func(arg, __assign(__assign({}, context), { emitContinue: function () {
                        shouldContinue = true;
                    } }));
                // Return a result if not undefined
                if (result != null) {
                    return { value: { value: result, shouldContinue: shouldContinue } };
                }
            };
            try {
                // Loop through each function
                for (var functionMaps_1 = (e_2 = void 0, __values(functionMaps)), functionMaps_1_1 = functionMaps_1.next(); !functionMaps_1_1.done; functionMaps_1_1 = functionMaps_1.next()) {
                    var functionMap = functionMaps_1_1.value;
                    var state_1 = _loop_1(functionMap);
                    if (typeof state_1 === "object")
                        return state_1.value;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (functionMaps_1_1 && !functionMaps_1_1.done && (_b = functionMaps_1.return)) _b.call(functionMaps_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return undefined;
}

function visitFeatures(node, context, emitMap) {
    var e_1, _a;
    var _b, _c;
    // TODO: optimize
    var visitMaps = context.flavors
        .map(function (flavor) { return flavor.discoverFeatures; })
        .filter(function (visitMap) { return visitMap != null; });
    try {
        for (var _d = __values(context.config.features || []), _e = _d.next(); !_e.done; _e = _d.next()) {
            var feature = _e.value;
            var result = executeFunctionsUntilMatch(visitMaps, feature, node, context);
            if (result != null) {
                (_c = (_b = emitMap)[feature]) === null || _c === void 0 ? void 0 : _c.call(_b, result.value);
                if (!result.shouldContinue)
                    return;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
        }
        finally { if (e_1) throw e_1.error; }
    }
    // Visit child nodes
    node.forEachChild(function (child) {
        visitFeatures(child, context, emitMap);
    });
}

function refineFeature$2(featureKind, value, context, emitMap) {
    /*if (Array.isArray(value)) {
        value.forEach(v => refineComponentFeature(featureKind, v, context, emitMap));
        return;
    }*/
    var e_1, _a, e_2, _b;
    var _c;
    var refinedValue = value;
    try {
        for (var _d = __values(context.flavors), _e = _d.next(); !_e.done; _e = _d.next()) {
            var flavor = _e.value;
            var refineFunc = (_c = flavor.refineFeature) === null || _c === void 0 ? void 0 : _c[featureKind];
            if (refineFunc != null) {
                if (refinedValue == null) {
                    return;
                }
                else if (Array.isArray(refinedValue)) {
                    var newValue = [];
                    try {
                        for (var refinedValue_1 = (e_2 = void 0, __values(refinedValue)), refinedValue_1_1 = refinedValue_1.next(); !refinedValue_1_1.done; refinedValue_1_1 = refinedValue_1.next()) {
                            var val = refinedValue_1_1.value;
                            var refined = refineFunc(val, context);
                            if (refined != null) {
                                newValue.push.apply(newValue, __spread((Array.isArray(refined) ? refined : [refined])));
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (refinedValue_1_1 && !refinedValue_1_1.done && (_b = refinedValue_1.return)) _b.call(refinedValue_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                    refinedValue = newValue.length === 0 ? undefined : newValue;
                }
                else {
                    refinedValue = refineFunc(refinedValue, context);
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (refinedValue != null) {
        (Array.isArray(refinedValue) ? refinedValue : [refinedValue]).forEach(function (v) { var _a, _b, _c; return (_c = (_a = emitMap) === null || _a === void 0 ? void 0 : (_b = _a)[featureKind]) === null || _c === void 0 ? void 0 : _c.call(_b, v); });
    }
}

function mergeJsDocIntoJsDoc(leftJsDoc, rightJsDoc) {
    var _a;
    if (leftJsDoc == null) {
        return rightJsDoc;
    }
    else if (rightJsDoc == null) {
        return leftJsDoc;
    }
    return __assign(__assign({}, ((leftJsDoc !== null && leftJsDoc !== void 0 ? leftJsDoc : rightJsDoc))), { description: (_a = leftJsDoc.description, (_a !== null && _a !== void 0 ? _a : rightJsDoc.description)) });
}
/**
 * Merges based on a name
 * @param entries
 * @param direction
 * @param getName
 * @param merge
 */
function mergeNamedEntries(entries, getName, merge) {
    var e_1, _a;
    var merged = new Map();
    try {
        for (var entries_1 = __values(entries), entries_1_1 = entries_1.next(); !entries_1_1.done; entries_1_1 = entries_1.next()) {
            var entry = entries_1_1.value;
            var name_1 = getName(entry);
            var existing = merged.get(name_1);
            if (existing == null) {
                merged.set(name_1, entry);
            }
            else if (merge != null) {
                merged.set(name_1, merge(existing, entry));
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (entries_1_1 && !entries_1_1.done && (_a = entries_1.return)) _a.call(entries_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return Array.from(merged.values());
}

function mergeSlots(slots) {
    return mergeNamedEntries(slots, function (slot) { return slot.name || ""; });
}
function mergeCssParts(cssParts) {
    return mergeNamedEntries(cssParts, function (cssPart) { return cssPart.name; });
}
function mergeCssProperties(cssProps) {
    return mergeNamedEntries(cssProps, function (cssProp) { return cssProp.name; });
}
function mergeMethods(methods) {
    return mergeNamedEntries(methods, function (method) { return method.name; }, function (left, right) { return (__assign(__assign({}, left), { jsDoc: mergeJsDocIntoJsDoc(left.jsDoc, right.jsDoc) })); });
}
function mergeEvents(events) {
    return mergeNamedEntries(events, function (event) { return event.name; }, function (left, right) { return (__assign(__assign({}, left), { jsDoc: mergeJsDocIntoJsDoc(left.jsDoc, right.jsDoc) })); });
}

var priorityValueMap = {
    low: 0,
    medium: 1,
    high: 2
};
function mergeMemberResults(memberResults, context) {
    var e_1, _a;
    // Start merging by sorting member results from high to low priority.
    // If two priorities are the same: prioritize the first found element
    memberResults.sort(function (a, b) {
        var vA = priorityValueMap[a.priority];
        var vB = priorityValueMap[b.priority];
        if (vA === vB) {
            var iA = memberResults.indexOf(a);
            var iB = memberResults.indexOf(b);
            return iA < iB ? -1 : 1;
        }
        return vA < vB ? 1 : -1;
    });
    // Keep track of merged props and merged attributes
    // These are stored in maps for speed, because we are going to lookup a member per each memberResult
    var mergeMap = {
        props: new Map(),
        attrs: new Map()
    };
    try {
        for (var memberResults_1 = __values(memberResults), memberResults_1_1 = memberResults_1.next(); !memberResults_1_1.done; memberResults_1_1 = memberResults_1.next()) {
            var member = memberResults_1_1.value.member;
            var mergeableMember = findMemberToMerge(member, mergeMap);
            var newMember = undefined;
            if (mergeableMember == null) {
                // No mergeable member was found, so just add this to the map
                newMember = member;
            }
            else {
                clearMergeMapWithMember(mergeableMember, mergeMap);
                clearMergeMapWithMember(member, mergeMap);
                newMember = mergeMemberIntoMember(mergeableMember, member, context.checker);
            }
            switch (newMember.kind) {
                case "attribute":
                    mergeMap.attrs.set(newMember.attrName, newMember);
                    break;
                case "property":
                    mergeMap.props.set(newMember.propName, newMember);
                    break;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (memberResults_1_1 && !memberResults_1_1.done && (_a = memberResults_1.return)) _a.call(memberResults_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    // Return merged results with only "high" priorities
    return __spread(mergeMap.props.values(), mergeMap.attrs.values()).map(function (member) { return ({ priority: "high", member: member }); });
}
function clearMergeMapWithMember(member, mergeMap) {
    switch (member.kind) {
        case "attribute":
            mergeMap.attrs.delete(member.attrName);
            break;
        case "property":
            mergeMap.props.delete(member.propName);
            if (member.attrName != null) {
                mergeMap.attrs.delete(member.attrName);
            }
            break;
    }
}
function findMemberToMerge(similar, mergeMap) {
    var e_2, _a;
    var attrName = similar.attrName; //?.toLowerCase(); // (similar.kind === "attribute" && similar.attrName.toLowerCase()) || undefined;
    var propName = similar.propName; /*?.toLowerCase()*/ //(similar.kind === "property" && similar.propName.toLowerCase()) || undefined;
    // Return a member that matches either propName (prioritized) or attrName
    if (propName != null) {
        var mergeable = mergeMap.props.get(propName) || mergeMap.attrs.get(propName);
        if (mergeable != null) {
            return mergeable;
        }
    }
    if (attrName != null) {
        var mergeableAttr = mergeMap.attrs.get(attrName);
        if (mergeableAttr != null) {
            return mergeableAttr;
        }
        // Try to find a prop with the attr name.
        // Don't return the prop if it already has an attribute that is not equals to the attr name
        var mergeableProp = mergeMap.props.get(attrName);
        if (mergeableProp != null && mergeableProp.attrName == null) {
            return mergeableProp;
        }
        try {
            for (var _b = __values(mergeMap.props.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var mergedAttr = _c.value;
                if (mergedAttr.attrName === attrName) {
                    return mergedAttr;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
}
/**
 * Merges two members of the same kind into each other.
 * This operation prioritizes leftMember
 * @param leftMember
 * @param rightMember
 * @param checker
 */
function mergeMemberIntoMember(leftMember, rightMember, checker) {
    var _a, _b, _c, _d, _e;
    // Always prioritize merging attribute into property if possible
    if (leftMember.kind === "attribute" && rightMember.kind === "property") {
        return mergeMemberIntoMember(rightMember, leftMember);
    }
    return __assign(__assign({}, leftMember), { attrName: (_a = leftMember.attrName, (_a !== null && _a !== void 0 ? _a : rightMember.attrName)), type: (function () {
            var _a, _b;
            // Always prioritize a "property" over an "attribute" when merging types
            if (leftMember.kind === rightMember.kind || leftMember.kind === "property") {
                return _a = leftMember.type, (_a !== null && _a !== void 0 ? _a : rightMember.type);
            }
            else if (rightMember.kind === "property") {
                return _b = rightMember.type, (_b !== null && _b !== void 0 ? _b : leftMember.type);
            }
        })(), jsDoc: mergeJsDocIntoJsDoc(leftMember.jsDoc, rightMember.jsDoc), meta: (_b = leftMember.meta, (_b !== null && _b !== void 0 ? _b : rightMember.meta)), default: leftMember.default === undefined ? rightMember.default : leftMember.default, required: (_c = leftMember.required, (_c !== null && _c !== void 0 ? _c : rightMember.required)), visibility: (_d = leftMember.visibility, (_d !== null && _d !== void 0 ? _d : rightMember.visibility)), deprecated: (_e = leftMember.deprecated, (_e !== null && _e !== void 0 ? _e : rightMember.deprecated)) });
}

function mergeFeatures(collection, context) {
    if (Array.isArray(collection)) {
        collection = {
            cssParts: arrayFlat(collection.map(function (c) { return c.cssParts; })),
            cssProperties: arrayFlat(collection.map(function (c) { return c.cssProperties; })),
            events: arrayFlat(collection.map(function (c) { return c.events; })),
            memberResults: arrayFlat(collection.map(function (c) { return c.memberResults; })),
            methods: arrayFlat(collection.map(function (c) { return c.methods; })),
            slots: arrayFlat(collection.map(function (c) { return c.slots; }))
        };
        return mergeFeatures(collection, context);
    }
    return {
        cssParts: mergeCssParts(collection.cssParts),
        cssProperties: mergeCssProperties(collection.cssProperties),
        events: mergeEvents(collection.events),
        memberResults: mergeMemberResults(collection.memberResults, context),
        methods: mergeMethods(collection.methods),
        slots: mergeSlots(collection.slots)
    };
}

function discoverFeatures$1(node, context) {
    if (context.cache.featureCollection.has(node)) {
        return context.cache.featureCollection.get(node);
    }
    var collection = {
        memberResults: [],
        methods: [],
        events: [],
        slots: [],
        cssProperties: [],
        cssParts: []
    };
    var refineEmitMap = {
        event: function (event) { return collection.events.push(event); },
        member: function (memberResult) { return collection.memberResults.push(memberResult); },
        csspart: function (cssPart) { return collection.cssParts.push(cssPart); },
        cssproperty: function (cssProperty) { return collection.cssProperties.push(cssProperty); },
        method: function (method) { return collection.methods.push(method); },
        slot: function (slot) { return collection.slots.push(slot); }
    };
    visitFeatures(node, context, {
        event: function (event) { return refineFeature$2("event", event, context, refineEmitMap); },
        member: function (memberResult) { return refineFeature$2("member", memberResult, context, refineEmitMap); },
        csspart: function (cssPart) { return refineFeature$2("csspart", cssPart, context, refineEmitMap); },
        cssproperty: function (cssProperty) { return refineFeature$2("cssproperty", cssProperty, context, refineEmitMap); },
        method: function (method) { return refineFeature$2("method", method, context, refineEmitMap); },
        slot: function (slot) { return refineFeature$2("slot", slot, context, refineEmitMap); }
    });
    return mergeFeatures(collection, context);
}

function visitAndExpandInheritClause(inheritClause, context) {
    var _a;
    var resolved = (function () {
        if (inheritClause.resolved == null)
            return undefined;
        return inheritClause.resolved.map(function (resolved) {
            var inheritance = [];
            visitInheritance(resolved.node, context, function (results) {
                inheritance = inheritance.concat(results);
            });
            return __assign(__assign({}, resolved), { inherits: inheritance });
        });
    })();
    return __assign(__assign({}, inheritClause), { horizontalInherits: (_a = inheritClause.horizontalInherits) === null || _a === void 0 ? void 0 : _a.map(function (arg) { return visitAndExpandInheritClause(arg, context); }), resolved: resolved });
}
function visitInheritance(node, context, emit) {
    var result = executeFunctionsUntilMatch(context.flavors, "discoverInheritance", node, context);
    if (result != null) {
        emit(result.value.map(function (link) { return visitAndExpandInheritClause(link, context); }));
        if (!result.shouldContinue)
            return;
    }
    // Visit child nodes
    /*node.forEachChild(child => {
     visitInheritance2(child, context, emit);
     });*/
}

function discoverInheritance$1(startNode, context) {
    var inherits = [];
    visitInheritance(startNode, context, function (link) {
        inherits = inherits.concat(link);
    });
    return {
        node: startNode,
        identifier: context.ts.isInterfaceDeclaration(startNode) || context.ts.isClassLike(startNode) ? startNode.name : undefined,
        inherits: inherits
    };
}

function excludeNode$2(node, context) {
    var e_1, _a;
    var _b, _c;
    try {
        for (var _d = __values(context.flavors), _e = _d.next(); !_e.done; _e = _d.next()) {
            var flavor = _e.value;
            var exclude = (_c = (_b = flavor).excludeNode) === null || _c === void 0 ? void 0 : _c.call(_b, node, context);
            if (exclude) {
                return true;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return false;
}

function refineDeclaration$1(declaration, context) {
    var e_1, _a;
    var _b, _c, _d;
    try {
        for (var _e = __values(context.flavors), _f = _e.next(); !_f.done; _f = _e.next()) {
            var flavor = _f.value;
            declaration = (_d = (_c = (_b = flavor).refineDeclaration) === null || _c === void 0 ? void 0 : _c.call(_b, declaration, context), (_d !== null && _d !== void 0 ? _d : declaration));
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return declaration;
}

function analyzeComponentDeclaration(declarationNode, context) {
    var e_1, _a;
    var inheritanceTree = discoverInheritance$1(declarationNode, context);
    var declarationNodes = getUniqueResolvedNodeForInheritanceTree(inheritanceTree);
    /*console.dir(
        Array.from(declarationNodes).map(n => n.getText()),
        { depth: 3 }
    );*/
    var featureCollections = [];
    try {
        for (var declarationNodes_1 = __values(declarationNodes), declarationNodes_1_1 = declarationNodes_1.next(); !declarationNodes_1_1.done; declarationNodes_1_1 = declarationNodes_1.next()) {
            var node = declarationNodes_1_1.value;
            if (shouldExcludeNode(node, context)) {
                continue;
            }
            featureCollections.push(discoverFeatures$1(node, context));
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (declarationNodes_1_1 && !declarationNodes_1_1.done && (_a = declarationNodes_1.return)) _a.call(declarationNodes_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    //console.dir(featureCollections, { depth: 4 });
    // If all nodes were excluded, return empty declaration
    if (featureCollections.length === 0) {
        return {
            events: [],
            cssParts: [],
            cssProperties: [],
            members: [],
            methods: [],
            slots: [],
            inheritanceTree: inheritanceTree,
            declarationNodes: declarationNodes,
            jsDoc: undefined
        };
    }
    var mergedFeatureCollection = featureCollections.length > 1 ? mergeFeatures(featureCollections, context) : featureCollections[0];
    //console.dir(mergedFeatureCollection, { depth: 3 });
    return refineDeclaration$1({
        cssParts: mergedFeatureCollection.cssParts,
        cssProperties: mergedFeatureCollection.cssProperties,
        events: mergedFeatureCollection.events,
        methods: mergedFeatureCollection.methods,
        members: mergedFeatureCollection.memberResults.map(function (_a) {
            var member = _a.member;
            return member;
        }),
        slots: mergedFeatureCollection.slots,
        declarationNodes: declarationNodes,
        inheritanceTree: inheritanceTree,
        jsDoc: getJsDoc(declarationNode, context.ts)
    }, context);
}
function shouldExcludeNode(node, context) {
    var _a;
    if (!context.config.analyzeLibDom && excludeNode$2(node.getSourceFile(), context)) {
        return true;
    }
    var name = getDeclarationName(node, context);
    if (name != null && ((_a = context.config.excludedDeclarationNames) === null || _a === void 0 ? void 0 : _a.includes(name))) {
        return true;
    }
    return false;
}
function getDeclarationName(node, context) {
    var _a, _b;
    if (context.ts.isClassLike(node) || context.ts.isInterfaceDeclaration(node)) {
        return (_a = node.name) === null || _a === void 0 ? void 0 : _a.text;
    }
    else if (context.ts.isVariableDeclaration(node)) {
        return (_b = node.name) === null || _b === void 0 ? void 0 : _b.getText();
    }
    return undefined;
}

function visitDefinitions(node, context, emit) {
    var result = executeFunctionsUntilMatch(context.flavors, "discoverDefinitions", node, context);
    if (result != null) {
        emit(result.value);
        if (!result.shouldContinue)
            return;
    }
    // Visit child nodes
    node.forEachChild(function (child) {
        visitDefinitions(child, context, emit);
    });
}

/**
 * Visits the source file and finds all component definitions as "customElements.define".
 * Next it dedupes definitions and parses the corresponding component declaration for each definition.
 * @param sourceFile
 * @param context
 * @param analyzeDeclaration
 */
function discoverDefinitions$4(sourceFile, context, analyzeDeclaration) {
    // Find all definitions in the file
    var definitionResults = analyzeAndDedupeDefinitions(sourceFile, context);
    return Array.from(definitionResults.entries()).map(function (_a) {
        var _b = __read(_a, 2), definition = _b[0], declarationSet = _b[1];
        return __assign(__assign({}, definition), { declaration: lazy(function () { return analyzeDeclaration(Array.from(declarationSet)); }) });
    });
    // Go through each component declaration parsing and merging declarations.
    // We can have many definition results for the same tag name but with different declaration nodes.
    /*const declarationMap = new Map<string, ComponentDeclaration>();
    for (const definitionResult of definitionResults) {
        // Merge the declarations if necessary
        const tagName = definitionResult.tagName;
        const existingDeclaration = declarationMap.get(tagName);

        if (existingDeclaration != null) {
            declarationMap.set(tagName, mergeDeclarations([declaration, existingDeclaration], context));
        } else {
            declarationMap.set(tagName, declaration);
        }
    }

    // Only emit one definition per tag name.
    return [...declarationMap.entries()].map(([tagName, declaration]) => {
        // Find the first definition result with this tag name in the list.
        const { definitionNode } = definitionResults.find(res => res.tagName === tagName)!;

        return {
            fromLib: isNodeInLibDom(definitionNode),
            node: definitionNode,
            tagName,
            declaration: expandDeclarationFromJsDoc(declaration)
        };
    });*/
}
/**
 * Finds all component definitions in a file.
 * @param node
 * @param context
 */
function analyzeAndDedupeDefinitions(node, context) {
    if (node == null)
        return new Map();
    var tagNameDefinitionMap = new Map();
    var definitionToDeclarationMap = new Map();
    visitDefinitions(node, context, function (results) {
        var e_1, _a;
        try {
            // Definitions are unique by tag name and are merged when pointing to multiple declaration nodes.
            // This is because multiple definitions can exist side by side for the same tag name (think global TagName type definition and customElements.define)
            for (var results_1 = __values(results), results_1_1 = results_1.next(); !results_1_1.done; results_1_1 = results_1.next()) {
                var result = results_1_1.value;
                var definition = tagNameDefinitionMap.get(result.tagName);
                if (definition == null) {
                    definition = {
                        declaration: function () {
                            throw new Error("This is a noop function. It's expected that this function is overwritten.");
                        },
                        fromLib: false,
                        tagName: result.tagName,
                        tagNameNodes: new Set(),
                        identifierNodes: new Set()
                    };
                    tagNameDefinitionMap.set(result.tagName, definition);
                }
                if (result.identifierNode != null) {
                    definition.identifierNodes.add(result.identifierNode);
                }
                if (result.tagNameNode) {
                    definition.tagNameNodes.add(result.tagNameNode);
                }
                var declarationNodeSet = definitionToDeclarationMap.get(definition);
                if (declarationNodeSet == null) {
                    declarationNodeSet = new Set();
                    definitionToDeclarationMap.set(definition, declarationNodeSet);
                }
                declarationNodeSet.add(result.declarationNode);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (results_1_1 && !results_1_1.done && (_a = results_1.return)) _a.call(results_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    });
    return definitionToDeclarationMap;
    /*const definitionContext: ComponentAnalyzerVisitContext = {
        ...context,
        emitDefinitionResult(result: DefinitionNodeResult): void {
            // Definitions are unique by the declaration node and tag name combination.
            // This is because multiple definitions can exist side by side for the same tag name (think global TagName type definition and customElements.define)
            const existingResult = resultMap.find(r => r.declarationNode === result.declarationNode && r.tagName === result.tagName);

            if (existingResult != null) {
                // Never overwrite a definition if it has a declaration handler.
                if (existingResult.declarationHandler != null) return;

                // Merge the two definitions.
                Object.assign(existingResult, result);
            } else {
                resultMap.push(result);
            }
        }
    };

    */
}

var ALL_COMPONENT_FEATURES = ["member", "method", "cssproperty", "csspart", "event", "slot"];

/**
 * Analyzes all components in a source file.
 * @param sourceFile
 * @param options
 */
function analyzeSourceFile(sourceFile, options) {
    // Assign defaults
    var flavors = options.flavors || DEFAULT_FLAVORS;
    var ts = options.ts || tsModule;
    var checker = options.checker;
    // Create context
    var context = {
        checker: checker,
        ts: ts,
        flavors: flavors,
        cache: {
            featureCollection: DEFAULT_FEATURE_COLLECTION_CACHE
        },
        config: __assign({ analyzeLibDom: false, excludedDeclarationNames: [], features: ALL_COMPONENT_FEATURES }, (options.config || {}))
    };
    // Parse all components
    var componentDefinitions = discoverDefinitions$4(sourceFile, context, function (declarationNodes) {
        return analyzeComponentDeclaration(Array.from(declarationNodes)[0], context);
    });
    // Parse all global events
    //const globalEvents = parseGlobalEvents(sourceFile, flavors, context);
    return {
        sourceFile: sourceFile,
        componentDefinitions: componentDefinitions,
        globalEvents: [],
        globalMembers: []
    };
}

function isTypescriptNode(value) {
    return value instanceof Object && "kind" in value && "flags" in value;
}
function isTypescriptSourceFile(value) {
    return value instanceof Object && "kind" in value && "fileName" in value;
}
function isTypescriptType(value) {
    return value instanceof Object && "flags" in value && "checker" in value;
}
function isSimpleType(value) {
    return value instanceof Object && "kind" in value && Object.values(SimpleTypeKind).includes(value.kind);
}
function stripTypescriptValues(input, checker) {
    var e_1, _a;
    var _b, _c, _d, _e, _f;
    if (input == null) {
        return input;
    }
    else if (typeof input === "function") {
        return stripTypescriptValues(input(), checker);
    }
    else if (isTypescriptNode(input)) {
        return "{NODE:" + ((_e = (_d = (_c = (_b = input).getSourceFile) === null || _c === void 0 ? void 0 : _c.call(_b)) === null || _d === void 0 ? void 0 : _d.fileName.match(".*/(.+)")) === null || _e === void 0 ? void 0 : _e[1]) + ":" + input.pos;
    }
    else if (isTypescriptSourceFile(input)) {
        return "{SOURCEFILE:" + ((_f = input.fileName.match(".*/(.+)")) === null || _f === void 0 ? void 0 : _f[1]) + "}";
    }
    else if (isTypescriptType(input)) {
        if (checker == null) {
            return "{TYPE}";
        }
        return "{TYPE:" + checker.typeToString(input) + "}";
    }
    else if (isSimpleType(input)) {
        return "{SIMPLETYPE:" + toTypeString(input) + "}";
    }
    else if (Array.isArray(input)) {
        return input.map(function (i) { return stripTypescriptValues(i, checker); });
    }
    else if (input instanceof Object) {
        var obj = __assign({}, input);
        try {
            for (var _g = __values(Object.entries(input)), _h = _g.next(); !_h.done; _h = _g.next()) {
                var _j = __read(_h.value, 2), key = _j[0], value = _j[1];
                obj[key] = stripTypescriptValues(value, checker);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_h && !_h.done && (_a = _g.return)) _a.call(_g);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return obj;
    }
    return input;
}

/**
 * Transforms results to json.
 * @param results
 * @param program
 * @param config
 */
var debugJsonTransformer = function (results, program, config) {
    var definitions = arrayFlat(results.map(function (res) { return res.componentDefinitions; }));
    return JSON.stringify(stripTypescriptValues(definitions, program.getTypeChecker()), null, 2);
};

var VISIBILITY_NUMBER_MAP = {
    private: 1,
    protected: 2,
    public: 3
};
function filterVisibility(visibility, array) {
    var target = VISIBILITY_NUMBER_MAP[visibility];
    return array.filter(function (item) { return VISIBILITY_NUMBER_MAP[item.visibility || "public"] >= target; });
}

/**
 * Transforms results to json.
 * @param results
 * @param program
 * @param config
 */
var jsonTransformer = function (results, program, config) {
    var checker = program.getTypeChecker();
    // Get all definitions
    var definitions = arrayFlat(results.map(function (res) { return res.componentDefinitions; }));
    // Transform all definitions into "tags"
    var tags = definitions.map(function (d) { return definitionToHtmlDataTag(d, checker, config); });
    var htmlData = {
        version: 2,
        tags: tags
    };
    return JSON.stringify(htmlData, null, 2);
};
function definitionToHtmlDataTag(definition, checker, config) {
    var declaration = definition.declaration();
    var attributes = filterVisibility(config.visibility, declaration.members)
        .map(function (d) { return componentMemberToHtmlDataAttribute(d, checker); })
        .filter(function (val) { return val != null; });
    var properties = filterVisibility(config.visibility, declaration.members)
        .map(function (d) { return componentMemberToHtmlDataProperty(d, checker); })
        .filter(function (val) { return val != null; });
    var events = filterVisibility(config.visibility, declaration.events)
        .map(function (e) { return componentEventToHtmlDataEvent(e); })
        .filter(function (val) { return val != null; });
    var slots = declaration.slots.map(function (e) { return componentSlotToHtmlDataSlot(e); }).filter(function (val) { return val != null; });
    var cssProperties = declaration.cssProperties
        .map(function (p) { return componentCssPropToHtmlCssProp(p); })
        .filter(function (val) { return val != null; });
    var cssParts = declaration.cssParts
        .map(function (p) { return componentCssPropToHtmlCssPart(p); })
        .filter(function (val) { return val != null; });
    return {
        name: definition.tagName,
        description: getDescriptionFromJsDoc(declaration.jsDoc),
        jsDoc: getJsDocTextFromJsDoc(declaration.jsDoc),
        attributes: attributes.length === 0 ? undefined : attributes,
        properties: properties.length === 0 ? undefined : properties,
        events: events.length === 0 ? undefined : events,
        slots: slots.length === 0 ? undefined : slots,
        cssProperties: cssProperties.length === 0 ? undefined : cssProperties,
        cssParts: cssParts.length === 0 ? undefined : cssParts
    };
}
function componentCssPropToHtmlCssProp(prop, checker) {
    return {
        name: prop.name || "",
        description: getDescriptionFromJsDoc(prop.jsDoc),
        jsDoc: getJsDocTextFromJsDoc(prop.jsDoc),
        type: prop.type
    };
}
function componentCssPropToHtmlCssPart(part, checker) {
    return {
        name: part.name || "",
        description: getDescriptionFromJsDoc(part.jsDoc),
        jsDoc: getJsDocTextFromJsDoc(part.jsDoc)
    };
}
function componentSlotToHtmlDataSlot(slot, checker) {
    return {
        name: slot.name || "",
        description: getDescriptionFromJsDoc(slot.jsDoc),
        jsDoc: getJsDocTextFromJsDoc(slot.jsDoc)
    };
}
function componentEventToHtmlDataEvent(event, checker) {
    return {
        name: event.name,
        description: getDescriptionFromJsDoc(event.jsDoc),
        jsDoc: getJsDocTextFromJsDoc(event.jsDoc)
    };
}
function componentMemberToHtmlDataAttribute(member, checker) {
    var _a;
    if (member.attrName == null) {
        return undefined;
    }
    return {
        name: member.attrName,
        description: getDescriptionFromJsDoc(member.jsDoc),
        jsDoc: getJsDocTextFromJsDoc(member.jsDoc),
        type: (_a = member.typeHint, (_a !== null && _a !== void 0 ? _a : (member.type != null ? getTypeHintFromType(member.type(), checker) : undefined))),
        default: member.default != null ? JSON.stringify(member.default) : undefined
    };
}
function componentMemberToHtmlDataProperty(member, checker) {
    var _a;
    if (member.propName == null) {
        return undefined;
    }
    return {
        name: member.propName,
        attribute: member.attrName,
        description: getDescriptionFromJsDoc(member.jsDoc),
        jsDoc: getJsDocTextFromJsDoc(member.jsDoc),
        type: (_a = member.typeHint, (_a !== null && _a !== void 0 ? _a : (member.type != null ? getTypeHintFromType(member.type(), checker) : undefined))),
        default: member.default != null ? JSON.stringify(member.default) : undefined
    };
}
function getDescriptionFromJsDoc(jsDoc) {
    var _a;
    return (_a = jsDoc) === null || _a === void 0 ? void 0 : _a.description;
}
function getJsDocTextFromJsDoc(jsDoc) {
    return jsDoc != null && jsDoc.node != null ? jsDoc.node.getText() : undefined;
}
function getTypeHintFromType(type, checker) {
    if (type == null)
        return undefined;
    var typeHint = isTypescriptType$1(type) ? checker.typeToString(type) : toTypeString(type);
    if (typeHint === "any")
        return undefined;
    return typeHint;
}
function isTypescriptType$1(value) {
    return value instanceof Object && "flags" in value && "checker" in value;
}

/**
 * Returns a markdown header with a specific level taking global start title level into account.
 * @param title
 * @param level
 * @param config
 */
function markdownHeader(title, level, config) {
    var _a;
    level = level - 1 + (((_a = config.markdown) === null || _a === void 0 ? void 0 : _a.titleLevel) || 1);
    return "#".repeat(level) + " " + title;
}
/**
 * Returns a markdown table representation of the rows.
 * Strips unused columns.
 * @param rows
 * @param removeEmptyColumns
 */
function markdownTable(rows, _a) {
    var removeEmptyColumns = (_a === void 0 ? { removeEmptyColumns: true } : _a).removeEmptyColumns;
    // Constants for pretty printing the markdown tables
    var MIN_CELL_WIDTH = 3;
    var MAX_CELL_WIDTH = 50;
    var CELL_PADDING = 1;
    // Count the number of columns
    var columnCount = Math.max.apply(Math, __spread(rows.map(function (r) { return r.length; })));
    if (removeEmptyColumns) {
        // Create a boolean array where each entry tells if a column is used or not (excluding the header)
        var emptyColumns_1 = Array(columnCount)
            .fill(false)
            .map(function (b, i) { return i !== 0 && rows.slice(1).find(function (r) { return r[i] != null && r[i].length > 0; }) == null; });
        // Remove unused columns if necessary
        if (emptyColumns_1.includes(true)) {
            // Filter out the unused columns in each row
            rows = rows.map(function (row) { return row.filter(function (column, i) { return !emptyColumns_1[i]; }); });
            // Adjust the column count
            columnCount = Math.max.apply(Math, __spread(rows.map(function (r) { return r.length; })));
        }
    }
    // Escape all cells in the markdown output
    rows = rows.map(function (r) { return r.map(markdownEscapeTableCell); });
    // Create a boolean array where each entry corresponds to the preferred column width.
    // This is done by taking the largest width of all cells in each column.
    var columnWidths = Array(columnCount)
        .fill(0)
        .map(function (c, i) { return Math.min(MAX_CELL_WIDTH, Math.max.apply(Math, __spread([MIN_CELL_WIDTH], rows.map(function (r) { return (r[i] || "").length; }))) + CELL_PADDING * 2); });
    // Build up the table
    return "\n|" + rows[0].map(function (r, i) { return fillWidth(r, columnWidths[i], CELL_PADDING); }).join("|") + "|\n|" + columnWidths.map(function (c) { return "-".repeat(c); }).join("|") + "|\n" + rows
        .slice(1)
        .map(function (r) { return "|" + r.map(function (r, i) { return fillWidth(r, columnWidths[i], CELL_PADDING); }).join("|") + "|"; })
        .join("\n") + "\n";
}
/**
 * Escape a text so it can be used in a markdown table
 * @param text
 */
function markdownEscapeTableCell(text) {
    return text.replace(/\n/g, "<br />").replace(/\|/g, "\\|");
}
/**
 * Highlights some text
 * @param text
 */
function markdownHighlight(text) {
    if (text == null || text.length === 0)
        return "";
    return "`" + text + "`";
}
/**
 * Creates padding around some text with a target width.
 * @param text
 * @param width
 * @param paddingStart
 */
function fillWidth(text, width, paddingStart) {
    return " ".repeat(paddingStart) + text + " ".repeat(Math.max(1, width - text.length - paddingStart));
}

/**
 * Transforms the component results to markdown
 * @param results
 * @param program
 * @param config
 */
var markdownTransformer = function (results, program, config) {
    // Grab all definitions
    var definitions = arrayFlat(results.map(function (res) { return res.componentDefinitions; }));
    // Transform all definitions to markdown
    var markdownSegments = definitions.map(function (definition) {
        var _a, _b;
        var declaration = definition.declaration();
        // Add tagName as header
        var segmentText = markdownHeader(definition.tagName, 1, config);
        // Add component jsdoc comment to the output
        if (((_a = declaration.jsDoc) === null || _a === void 0 ? void 0 : _a.description) != null)
            segmentText += "\n\n" + ((_b = declaration.jsDoc) === null || _b === void 0 ? void 0 : _b.description) + "\n";
        // Grab all items from the component and add them as tables to the output.
        var properties = filterVisibility(config.visibility, declaration.members.filter(function (m) { return m.kind === "property"; }).sort(function (a, b) { return (a.propName < b.propName ? -1 : 1); }));
        var attributes = filterVisibility(config.visibility, declaration.members.filter(function (m) { return m.kind === "attribute"; }).sort(function (a, b) { return (a.attrName < b.attrName ? -1 : 1); }));
        var methods = filterVisibility(config.visibility, declaration.methods.sort(function (a, b) { return (a.name < b.name ? -1 : 1); }));
        var slots = declaration.slots.sort(function (a, b) { return (a.name == null ? -1 : b.name == null ? 1 : a.name < b.name ? -1 : 1); });
        var events = declaration.events.sort(function (a, b) { return (a.name < b.name ? -1 : 1); });
        var cssProps = declaration.cssProperties.sort(function (a, b) { return (a.name < b.name ? -1 : 1); });
        var cssParts = declaration.cssParts.sort(function (a, b) { return (a.name < b.name ? -1 : 1); });
        if (attributes.length > 0) {
            segmentText += "\n" + memberAttributeSection(attributes, program.getTypeChecker(), config);
        }
        if (properties.length > 0) {
            segmentText += "\n" + memberPropertySection(properties, program.getTypeChecker(), config);
        }
        if (methods.length > 0) {
            segmentText += "\n" + methodSection(methods, program.getTypeChecker(), config);
        }
        if (events.length > 0) {
            segmentText += "\n" + eventSection(events, program.getTypeChecker(), config);
        }
        if (slots.length > 0) {
            segmentText += "\n" + slotSection(slots, config);
        }
        if (cssParts.length > 0) {
            segmentText += "\n" + cssPartSection(cssParts, config);
        }
        if (cssProps.length > 0) {
            segmentText += "\n" + cssPropSection(cssProps, config);
        }
        return segmentText;
    });
    return markdownSegments.join("\n\n");
};
/**
 * Returns a markdown table with css props
 * @param cssProperty
 * @param config
 */
function cssPropSection(cssProperty, config) {
    var rows = [["Property", "Description"]];
    rows.push.apply(rows, __spread(cssProperty.map(function (prop) { var _a; return [(prop.name && markdownHighlight(prop.name)) || "", ((_a = prop.jsDoc) === null || _a === void 0 ? void 0 : _a.description) || ""]; })));
    return markdownHeader("CSS Custom Properties", 2, config) + "\n" + markdownTable(rows);
}
/**
 * Returns a markdown table with css parts
 * @param cssPart
 * @param config
 */
function cssPartSection(cssPart, config) {
    var rows = [["Part", "Description"]];
    rows.push.apply(rows, __spread(cssPart.map(function (part) { var _a; return [(part.name && markdownHighlight(part.name)) || "", ((_a = part.jsDoc) === null || _a === void 0 ? void 0 : _a.description) || ""]; })));
    return markdownHeader("CSS Shadow Parts", 2, config) + "\n" + markdownTable(rows);
}
function shouldShowVisibility(items, config) {
    return config.visibility !== "public" && items.some(function (method) { return method.visibility != null && method.visibility !== "public"; });
}
/**
 * Returns a markdown table with methods
 * @param methods
 * @param checker
 * @param config
 */
function methodSection(methods, checker, config) {
    var showVisibility = shouldShowVisibility(methods, config);
    var rows = [__spread(["Method"], (showVisibility ? ["Visibility"] : []), ["Description"])];
    rows.push.apply(rows, __spread(methods.map(function (method) {
        var _a;
        return __spread([
            method.name != null ? markdownHighlight(method.name) : ""
        ], (showVisibility ? [method.visibility || "public"] : []), [
            ((_a = method.jsDoc) === null || _a === void 0 ? void 0 : _a.description) || ""
        ]);
    })));
    return markdownHeader("Methods", 2, config) + "\n" + markdownTable(rows);
}
/**
 * Returns a markdown table with events
 * @param events
 * @param config
 * @param checker
 */
function eventSection(events, checker, config) {
    var showVisibility = shouldShowVisibility(events, config);
    var rows = [__spread(["Event"], (showVisibility ? ["Visibility"] : []), ["Detail", "Description"])];
    rows.push.apply(rows, __spread(events.map(function (event) {
        var _a;
        return __spread([
            (event.name && markdownHighlight(event.name)) || ""
        ], (showVisibility ? [event.visibility || "public"] : []), [
            isAssignableToSimpleTypeKind(event.type(), SimpleTypeKind.ANY, checker) ? "" : markdownHighlight(toTypeString(event.type(), checker)),
            ((_a = event.jsDoc) === null || _a === void 0 ? void 0 : _a.description) || ""
        ]);
    })));
    return markdownHeader("Events", 2, config) + "\n" + markdownTable(rows);
}
/**
 * Returns a markdown table with slots
 * @param slots
 * @param config
 */
function slotSection(slots, config) {
    var rows = [["Name", "Permitted Tag Names", "Description"]];
    rows.push.apply(rows, __spread(slots.map(function (slot) {
        var _a;
        return [
            (slot.name && markdownHighlight(slot.name)) || "",
            (slot.permittedTagNames && slot.permittedTagNames.map(function (tagName) { return markdownHighlight(tagName); }).join(" | ")) || "",
            ((_a = slot.jsDoc) === null || _a === void 0 ? void 0 : _a.description) || ""
        ];
    })));
    return markdownHeader("Slots", 2, config) + "\n" + markdownTable(rows);
}
/**
 * Returns a markdown table with attributes.
 * @param members
 * @param checker
 * @param config
 */
function memberAttributeSection(members, checker, config) {
    var e_1, _a;
    var _b, _c, _d, _e;
    var showVisibility = shouldShowVisibility(members, config);
    var rows = [__spread(["Attribute"], (showVisibility ? ["Visibility"] : []), ["Type", "Default", "Description"])];
    try {
        // Add members as rows one by one
        for (var members_1 = __values(members), members_1_1 = members_1.next(); !members_1_1.done; members_1_1 = members_1.next()) {
            var member = members_1_1.value;
            var attrName = markdownHighlight(member.attrName);
            var type = markdownHighlight(getTypeHintFromType$1((_b = member.typeHint, (_b !== null && _b !== void 0 ? _b : (_d = (_c = member).type) === null || _d === void 0 ? void 0 : _d.call(_c))), checker));
            var visibility = member.visibility || "public";
            var def = (member.default !== undefined ? JSON.stringify(member.default) : "") || (member.required && "**required**") || "";
            var comment = ((_e = member.jsDoc) === null || _e === void 0 ? void 0 : _e.description) || "";
            rows.push(__spread([attrName], (showVisibility ? [visibility] : []), [type, def, comment]));
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (members_1_1 && !members_1_1.done && (_a = members_1.return)) _a.call(members_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return markdownHeader("Attributes", 2, config) + "\n" + markdownTable(rows);
}
/**
 * Returns a markdown table with properties
 * @param members
 * @param checker
 * @param config
 */
function memberPropertySection(members, checker, config) {
    var e_2, _a;
    var _b, _c, _d, _e;
    var showVisibility = shouldShowVisibility(members, config);
    var rows = [__spread(["Property", "Attribute"], (showVisibility ? ["Visibility"] : []), ["Type", "Default", "Description"])];
    try {
        // Add properties as rows one by one
        for (var members_2 = __values(members), members_2_1 = members_2.next(); !members_2_1.done; members_2_1 = members_2.next()) {
            var member = members_2_1.value;
            var propName = markdownHighlight(member.propName);
            var attrName = (member.attrName && markdownHighlight(member.attrName)) || "";
            var visibility = member.visibility || "public";
            var type = markdownHighlight(getTypeHintFromType$1((_b = member.typeHint, (_b !== null && _b !== void 0 ? _b : (_d = (_c = member).type) === null || _d === void 0 ? void 0 : _d.call(_c))), checker));
            var def = (member.default !== undefined ? JSON.stringify(member.default) : "") || (member.required && "**required**") || "";
            var comment = ((_e = member.jsDoc) === null || _e === void 0 ? void 0 : _e.description) || "";
            rows.push(__spread([propName, attrName], (showVisibility ? [visibility] : []), [type, def, comment]));
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (members_2_1 && !members_2_1.done && (_a = members_2.return)) _a.call(members_2);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return markdownHeader("Properties", 2, config) + "\n" + markdownTable(rows);
}
function getTypeHintFromType$1(type, checker) {
    if (type == null)
        return undefined;
    if (typeof type === "string")
        return type;
    var typeHint = toTypeString(type, checker);
    if (typeHint === "any")
        return undefined;
    if (typeHint === "{}")
        return "object";
    return typeHint;
}

/**
 * Vscode json output format transformer.
 * @param results
 * @param program
 * @param config
 */
var vscodeTransformer = function (results, program, config) {
    var checker = program.getTypeChecker();
    // Grab all definitions
    var definitions = results.map(function (res) { return res.componentDefinitions; }).reduce(function (acc, cur) { return __spread(acc, cur); }, []);
    // Transform all definitions into "tags"
    var tags = definitions.map(function (d) { return definitionToHtmlDataTag$1(d, checker); });
    var vscodeJson = {
        version: 1,
        tags: tags,
        globalAttributes: [],
        valueSets: []
    };
    return JSON.stringify(vscodeJson, null, 2);
};
function definitionToHtmlDataTag$1(definition, checker) {
    var declaration = definition.declaration();
    // Transform all members into "attributes"
    var customElementAttributes = declaration.members
        .map(function (d) { return componentMemberToVscodeAttr(d, checker); })
        .filter(function (val) { return val != null; });
    var eventAttributes = declaration.events
        .map(function (e) { return componentEventToVscodeAttr(e, checker); })
        .filter(function (val) { return val != null; });
    var attributes = __spread(customElementAttributes, eventAttributes);
    return {
        name: definition.tagName,
        description: formatMetadata(declaration.jsDoc, {
            Events: declaration.events.map(function (e) { var _a, _b; return formatEntryRow(e.name, e.jsDoc, (_b = (_a = e).type) === null || _b === void 0 ? void 0 : _b.call(_a), checker); }),
            Slots: declaration.slots.map(function (s) {
                return formatEntryRow(s.name || " ", s.jsDoc, s.permittedTagNames && s.permittedTagNames.map(function (n) { return "\"" + markdownHighlight(n) + "\""; }).join(" | "), checker);
            }),
            Attributes: declaration.members
                .map(function (m) { var _a, _b; return ("attrName" in m && m.attrName != null ? formatEntryRow(m.attrName, m.jsDoc, m.typeHint || ((_b = (_a = m).type) === null || _b === void 0 ? void 0 : _b.call(_a)), checker) : undefined); })
                .filter(function (m) { return m != null; }),
            Properties: declaration.members
                .map(function (m) { var _a, _b; return ("propName" in m && m.propName != null ? formatEntryRow(m.propName, m.jsDoc, m.typeHint || ((_b = (_a = m).type) === null || _b === void 0 ? void 0 : _b.call(_a)), checker) : undefined); })
                .filter(function (m) { return m != null; })
        }),
        attributes: attributes
    };
}
function componentEventToVscodeAttr(event, checker) {
    var _a, _b;
    return {
        name: "on" + event.name,
        description: formatEntryRow(event.name, event.jsDoc, (_b = (_a = event).type) === null || _b === void 0 ? void 0 : _b.call(_a), checker)
    };
}
function componentMemberToVscodeAttr(member, checker) {
    var _a, _b, _c, _d;
    if (member.attrName == null) {
        return undefined;
    }
    return __assign({ name: member.attrName, description: formatMetadata(formatEntryRow(member.attrName, member.jsDoc, member.typeHint || ((_b = (_a = member).type) === null || _b === void 0 ? void 0 : _b.call(_a)), checker), {
            Property: "propName" in member ? member.propName : undefined,
            Default: member.default === undefined ? undefined : String(member.default)
        }) }, ((member.type && typeToVscodeValuePart((_d = (_c = member).type) === null || _d === void 0 ? void 0 : _d.call(_c), checker)) || {}));
}
/**
 * Converts a type to either a value set or string unions.
 * @param type
 * @param checker
 */
function typeToVscodeValuePart(type, checker) {
    var simpleType = isSimpleType$1(type) ? type : toSimpleType(type, checker);
    switch (simpleType.kind) {
        case SimpleTypeKind.BOOLEAN:
            return { valueSet: "v" };
        case SimpleTypeKind.STRING_LITERAL:
            return { values: [{ name: simpleType.value }] };
        case SimpleTypeKind.ENUM:
            return { values: typesToStringUnion(simpleType.types.map(function (_a) {
                    var type = _a.type;
                    return type;
                })) };
        case SimpleTypeKind.UNION:
            return { values: typesToStringUnion(simpleType.types) };
    }
    return undefined;
}
/**
 * Returns a list of strings that represents the types.
 * Only looks at literal types and strips the rest.
 * @param types
 */
function typesToStringUnion(types) {
    return types
        .map(function (t) {
        switch (t.kind) {
            case SimpleTypeKind.STRING_LITERAL:
            case SimpleTypeKind.NUMBER_LITERAL:
                return { name: t.value.toString() };
            default:
                return undefined;
        }
    })
        .filter(function (val) { return val != null; });
}
/**
 * Formats description and metadata so that it can be used in documentation.
 * @param doc
 * @param metadata
 */
function formatMetadata(doc, metadata) {
    var _a;
    var metaText = Object.entries(metadata)
        .map(function (_a) {
        var _b = __read(_a, 2), key = _b[0], value = _b[1];
        if (value == null) {
            return undefined;
        }
        else if (Array.isArray(value)) {
            var filtered = value.filter(function (v) { return v != null; });
            if (filtered.length === 0)
                return undefined;
            return key + ":\n\n" + filtered.map(function (v) { return "  * " + v; }).join("\n\n");
        }
        else {
            return key + ": " + value;
        }
    })
        .filter(function (value) { return value != null; })
        .join("\n\n");
    var comment = typeof doc === "string" ? doc : ((_a = doc) === null || _a === void 0 ? void 0 : _a.description) || "";
    return "" + (comment || "") + (metadata ? "" + (comment ? "\n\n" : "") + metaText : "") || undefined;
}
/**
 * Formats name, doc and type so that it can be presented in documentation
 * @param name
 * @param doc
 * @param type
 * @param checker
 */
function formatEntryRow(name, doc, type, checker) {
    var _a;
    var comment = typeof doc === "string" ? doc : ((_a = doc) === null || _a === void 0 ? void 0 : _a.description) || "";
    var typeText = typeof type === "string" ? type : type == null ? "" : formatType(type, checker);
    return "" + markdownHighlight(name) + (typeText == null ? "" : " {" + typeText + "}") + (comment == null ? "" : " - ") + (comment || "");
}
/**
 * Formats a type to present in documentation
 * @param type
 * @param checker
 */
function formatType(type, checker) {
    return !isAssignableToSimpleTypeKind(type, SimpleTypeKind.ANY, checker) ? markdownHighlight(toTypeString(type, checker)) : undefined;
}

var transformerFunctionMap = {
    debug: debugJsonTransformer,
    json: jsonTransformer,
    markdown: markdownTransformer,
    md: markdownTransformer,
    vscode: vscodeTransformer
};
function transformAnalyzerResult(kind, results, program, config) {
    var func = transformerFunctionMap[kind];
    if (func == null) {
        throw new Error("Couldn't find transformer function for transformer kind: " + kind);
    }
    return func(Array.isArray(results) ? results : [results], program, config);
}

export { ALL_COMPONENT_FEATURES as A, CustomElementFlavor as C, DEFAULT_FEATURE_COLLECTION_CACHE as D, VERSION as V, __assign as _, analyzeSourceFile as a, analyzeComponentDeclaration as b, __awaiter as c, __generator as d, __values as e, arrayFlat as f, __spread as g, __extends as h, __read as i, stripTypescriptValues as s, transformAnalyzerResult as t };
