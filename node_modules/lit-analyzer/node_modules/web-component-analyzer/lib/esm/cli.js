import { c as __awaiter, d as __generator, a as analyzeSourceFile, s as stripTypescriptValues, e as __values, f as arrayFlat, g as __spread, h as __extends, t as transformAnalyzerResult, _ as __assign, i as __read, V as VERSION } from './chunk-1f25694a.js';
import { ScriptTarget, ModuleKind, ModuleResolutionKind, createProgram, getPreEmitDiagnostics, flattenDiagnosticMessageText } from 'typescript';
import 'ts-simple-type';
import { existsSync, lstatSync, writeFileSync, mkdirSync } from 'fs';
import { join, resolve, extname } from 'path';
import fastGlob from 'fast-glob';

/**
 * The most general version of compiler options.
 */
var defaultOptions = {
    noEmitOnError: false,
    allowJs: true,
    experimentalDecorators: true,
    target: ScriptTarget.Latest,
    downlevelIteration: true,
    module: ModuleKind.ESNext,
    //module: ModuleKind.CommonJS,
    //lib: ["esnext", "dom"],
    strictNullChecks: true,
    moduleResolution: ModuleResolutionKind.NodeJs,
    esModuleInterop: true,
    noEmit: true,
    allowSyntheticDefaultImports: true,
    allowUnreachableCode: true,
    allowUnusedLabels: true,
    skipLibCheck: true,
    isolatedModules: true
};
/**
 * Compiles an array of file paths using typescript.
 * @param filePaths
 * @param options
 */
function compileTypescript(filePaths, options) {
    if (options === void 0) { options = defaultOptions; }
    filePaths = Array.isArray(filePaths) ? filePaths : [filePaths];
    var program = createProgram(filePaths, options);
    var diagnostics = getPreEmitDiagnostics(program);
    var files = program.getSourceFiles().filter(function (sf) { return filePaths.includes(sf.fileName); });
    return { diagnostics: diagnostics, program: program, files: files };
}

var IGNORE_GLOBS = ["!**/node_modules/**", "!**/web_modules/**"];
//const DEFAULT_DIR_GLOB = "{,!(node_modules|web_modules)/}**/*.{js,jsx,ts,tsx}";
var DEFAULT_DIR_GLOB = "**/*.{js,jsx,ts,tsx}";
//const DEFAULT_FILE_GLOB = "**/*.{js,jsx,ts,tsx}";
var DEFAULT_GLOBS = [DEFAULT_DIR_GLOB]; //, DEFAULT_FILE_GLOB];
/**
 * Parses and analyses all globs and calls some callbacks while doing it.
 * @param globs
 * @param config
 * @param context
 */
function analyzeGlobs(globs, config, context) {
    if (context === void 0) { context = {}; }
    return __awaiter(this, void 0, void 0, function () {
        var filePaths, _a, program, files, diagnostics, results, files_1, files_1_1, file, result, e_1_1;
        var e_1, _b;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    // Set default glob
                    if (globs.length === 0) {
                        globs = DEFAULT_GLOBS;
                    }
                    return [4 /*yield*/, expandGlobs(globs, config)];
                case 1:
                    filePaths = _c.sent();
                    if (config.debug) {
                        console.log(filePaths);
                    }
                    // Callbacks
                    if (context.didExpandGlobs != null)
                        context.didExpandGlobs(filePaths);
                    if (context.willAnalyzeFiles != null)
                        context.willAnalyzeFiles(filePaths);
                    _a = compileTypescript(filePaths), program = _a.program, files = _a.files, diagnostics = _a.diagnostics;
                    if (diagnostics.length > 0) {
                        if (config.debug) {
                            console.dir(diagnostics.map(function (d) { return ((d.file && d.file.fileName) || "unknown") + ": " + flattenDiagnosticMessageText(d.messageText, "\n"); }));
                        }
                        if (context.didFindTypescriptDiagnostics != null)
                            context.didFindTypescriptDiagnostics(diagnostics, { program: program });
                    }
                    results = [];
                    _c.label = 2;
                case 2:
                    _c.trys.push([2, 8, 9, 10]);
                    files_1 = __values(files), files_1_1 = files_1.next();
                    _c.label = 3;
                case 3:
                    if (!!files_1_1.done) return [3 /*break*/, 7];
                    file = files_1_1.value;
                    result = analyzeComponentsInFile(file, program, config);
                    if (config.debug) {
                        console.dir(stripTypescriptValues(result, program.getTypeChecker()), { depth: 10 });
                    }
                    if (!(context.emitAnalyzedFile != null)) return [3 /*break*/, 5];
                    return [4 /*yield*/, context.emitAnalyzedFile(file, result, { program: program })];
                case 4:
                    _c.sent();
                    _c.label = 5;
                case 5:
                    results.push(result);
                    _c.label = 6;
                case 6:
                    files_1_1 = files_1.next();
                    return [3 /*break*/, 3];
                case 7: return [3 /*break*/, 10];
                case 8:
                    e_1_1 = _c.sent();
                    e_1 = { error: e_1_1 };
                    return [3 /*break*/, 10];
                case 9:
                    try {
                        if (files_1_1 && !files_1_1.done && (_b = files_1.return)) _b.call(files_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                    return [7 /*endfinally*/];
                case 10: return [2 /*return*/, { program: program, diagnostics: diagnostics, files: files, results: results }];
            }
        });
    });
}
/**
 * Analyze all components in the typescript sourcefile using web component analyzer.
 * @param file
 * @param program
 * @param config
 */
function analyzeComponentsInFile(file, program, config) {
    var options = {
        checker: program.getTypeChecker(),
        config: config.analyze
    };
    return analyzeSourceFile(file, options);
}
/**
 * Expands the globs.
 * @param globs
 * @param config
 */
function expandGlobs(globs, config) {
    return __awaiter(this, void 0, void 0, function () {
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    globs = Array.isArray(globs) ? globs : [globs];
                    _a = arrayFlat;
                    return [4 /*yield*/, Promise.all(globs.map(function (g) {
                            try {
                                // Test if the glob points to a directory.
                                // If so, return the result of a new glob that searches for files in the directory excluding node_modules..
                                var dirExists = existsSync(g) && lstatSync(g).isDirectory();
                                if (dirExists) {
                                    return fastGlob(__spread((config.discoverLibraryFiles || g.includes("node_modules") ? [] : IGNORE_GLOBS), [join(g, DEFAULT_DIR_GLOB)]), {
                                        absolute: true,
                                        followSymbolicLinks: false
                                    });
                                }
                            }
                            catch (e) { }
                            // Return the result of globbing
                            return fastGlob(__spread((config.discoverLibraryFiles || g.includes("node_modules") ? [] : IGNORE_GLOBS), [g]), {
                                absolute: true,
                                followSymbolicLinks: false
                            });
                        }))];
                case 1: return [2 /*return*/, _a.apply(void 0, [_b.sent()])];
            }
        });
    });
}

var CommandError = /** @class */ (function (_super) {
    __extends(CommandError, _super);
    function CommandError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return CommandError;
}(Error));

/**
 * A CLI command for analyzing components.
 */
var AnalyzeCliCommand = /** @class */ (function () {
    function AnalyzeCliCommand() {
        this.id = "analyze";
    }
    /**
     * Prints help for this command.
     */
    AnalyzeCliCommand.prototype.printHelp = function () {
        console.log("Usage:\n  $ wca analyze [<input-glob>] [options]\n  \nExamples:\n  $ wca analyze\n  $ wca analyze src --format markdown\n  $ wca analyze \"src/**/*.{js,ts}\" --outDir output\n  $ wca analyze my-element.js --outFile output.json\n\nOptions:\n  --help\t\tPrint this message.\n  --format FORMAT\tSpecify output format. The possible options are:\n\t\t\t  o md | markdown\tMarkdown format (default)\n\t\t\t  o json\t\tJSON format\n\t\t\t  o vscode\t\tVscode JSON format\n  --outFile FILE\tConcatenate and emit output to a single file.\n  --outDir DIRECTORY\tDirect output to a directory where each file corresponds to a web component.\n");
    };
    /**
     * Runs the analyze cli command.
     * @param config
     * @param inputGlobs
     */
    AnalyzeCliCommand.prototype.run = function (config) {
        var inputGlobs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            inputGlobs[_i - 1] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            var context, dirPath_1, extName_1, _a, results, program, transformed, path;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        context = {
                            didExpandGlobs: function (filePaths) {
                                if (filePaths.length === 0) {
                                    throw new CommandError("Didn't find any files to analyze.");
                                }
                            },
                            willAnalyzeFiles: function (filePaths) {
                                console.log("Analyzing " + filePaths.length + " file" + (filePaths.length === 1 ? "" : "s") + "...");
                            }
                        };
                        if (!(config.outDir != null)) return [3 /*break*/, 2];
                        // Create the directory if it doesn't exist.
                        if (!existsSync(config.outDir)) {
                            mkdirSync(config.outDir);
                        }
                        dirPath_1 = config.outDir;
                        extName_1 = (function () {
                            switch (config.format) {
                                case "json":
                                case "vscode":
                                    return ".json";
                                case "md":
                                case "markdown":
                                    return ".md";
                                default:
                                    return ".txt";
                            }
                        })();
                        // Analyze all globs
                        return [4 /*yield*/, analyzeGlobs(inputGlobs, config, __assign(__assign({}, context), { emitAnalyzedFile: function (file, result, _a) {
                                    var program = _a.program;
                                    // Write file to disc for each analyzed file
                                    var definition = result.componentDefinitions[0];
                                    if (definition == null)
                                        return;
                                    // The name of the file becomes the tagName of the first component definition in the file.
                                    var path = resolve(process.cwd(), dirPath_1, definition.tagName) + extName_1;
                                    var transformed = _this.transformResults(result, program, config);
                                    writeFileSync(path, transformed);
                                } }))];
                    case 1:
                        // Analyze all globs
                        _b.sent();
                        return [3 /*break*/, 6];
                    case 2:
                        if (!(config.outFile != null)) return [3 /*break*/, 4];
                        // Guess format based on outFile extension
                        config.format =
                            config.format ||
                                (function () {
                                    if (config.outFile == null)
                                        return undefined;
                                    var extName = extname(config.outFile);
                                    switch (extName) {
                                        case ".json":
                                            return "json";
                                        case ".md":
                                            return "markdown";
                                    }
                                })() ||
                                "markdown";
                        return [4 /*yield*/, analyzeGlobs(inputGlobs, config, context)];
                    case 3:
                        _a = _b.sent(), results = _a.results, program = _a.program;
                        transformed = this.transformResults(results, program, config);
                        path = resolve(process.cwd(), config.outFile);
                        console.log("Writing result to \"" + config.outFile + "\"");
                        writeFileSync(path, transformed);
                        return [3 /*break*/, 6];
                    case 4: return [4 /*yield*/, analyzeGlobs(inputGlobs, config, __assign(__assign({}, context), { emitAnalyzedFile: function (file, result, _a) {
                                var program = _a.program;
                                // Only emit the result if there is in fact components in the file.
                                if (result.componentDefinitions.length > 0 || result.globalEvents.length > 0) {
                                    var transformed = _this.transformResults(result, program, config);
                                    console.log(transformed);
                                }
                            } }))];
                    case 5:
                        _b.sent();
                        _b.label = 6;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Analyzes input globs and returns the transformed result.
     * @param inputGlobs
     * @param config
     */
    AnalyzeCliCommand.prototype.analyze = function (inputGlobs, config) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, results, program;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, analyzeGlobs(Array.isArray(inputGlobs) ? inputGlobs : [inputGlobs], config)];
                    case 1:
                        _a = _b.sent(), results = _a.results, program = _a.program;
                        return [2 /*return*/, this.transformResults(results, program, config)];
                }
            });
        });
    };
    /**
     * Transforms analyze results based on the wca cli config.
     * @param results
     * @param program
     * @param config
     */
    AnalyzeCliCommand.prototype.transformResults = function (results, program, config) {
        results = Array.isArray(results) ? results : [results];
        // Default format is "markdown"
        var format = config.format || "markdown";
        var transformerConfig = {
            visibility: config.visibility || "public",
            markdown: config.markdown
        };
        if (format === "json") {
            console.log("\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
            console.log("  WARNING: This json format is for experimental and demo purposes. You can expect changes to this format.");
            console.log("  Please follow and contribute to the discussion at:");
            console.log("  - https://github.com/webcomponents/custom-elements-json");
            console.log("  - https://github.com/w3c/webcomponents/issues/776");
            console.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
        }
        return transformAnalyzerResult(format, results, program, transformerConfig);
    };
    return AnalyzeCliCommand;
}());

/**
 * Parses CLI arguments.
 * @param args
 */
function parseCliArguments(args) {
    var result = { _: [] };
    for (var i = 0; i < args.length; i++) {
        var arg = args[i];
        // Parses: "--key", "-k", "--key=value", "--key value"
        if (arg.startsWith("-")) {
            // Parses: "--key=value"
            if (arg.includes("=")) {
                var _a = __read(arg.split("="), 2), key = _a[0], value = _a[1];
                assignValue(result, key, value);
            }
            // Parses: "--key value", "--key", "-k
            else {
                var key = transformKey(arg);
                // Parses: "--key value"
                if (i < args.length - 1) {
                    var value = args[i + 1];
                    if (!value.startsWith("-")) {
                        assignValue(result, key, value);
                        i++;
                        continue;
                    }
                }
                // Parses: "--key", "-k"
                assignValue(result, key, true);
            }
        }
        // Parses: "arg1", "arg2", ...
        else {
            result._.push(arg);
        }
    }
    return result;
}
/**
 * Transform a string to a primitive type.
 * @param value
 */
function transformValue(value) {
    if (typeof value === "boolean") {
        return value;
    }
    else if (!isNaN(Number(value))) {
        return Number(value);
    }
    else if (value === "true" || value === "false") {
        return value === "true";
    }
    return value;
}
/**
 * Transform a key by removing the first "-" characters.
 * @param key
 */
function transformKey(key) {
    return key.replace(/^-*/g, "");
}
/**
 * Assigns a value on a specific key and transforms the value at the same time.
 * @param obj
 * @param key
 * @param value
 */
function assignValue(obj, key, value) {
    // The key could be "nested.key"
    var keys = transformKey(key).split(".");
    keys.forEach(function (k, i) {
        // Assign the final value
        if (i >= keys.length - 1) {
            obj[k] = transformValue(value);
        }
        // Create nested objects
        else {
            if (!(k in obj)) {
                obj[k] = {};
            }
            obj = obj[k];
        }
    });
}

/**
 * The main function of the cli.
 */
function cli() {
    return __awaiter(this, void 0, void 0, function () {
        var commands, args, commandId, command, exitCode, error_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    commands = [new AnalyzeCliCommand()];
                    args = parseCliArguments(process.argv.slice(2));
                    if ("debug" in args && args.debug) {
                        console.dir(args);
                    }
                    commandId = args._[0];
                    command = commands.find(function (c) { return c.id === commandId; });
                    // Print "version"
                    if ("version" in args) {
                        console.log(VERSION);
                        process.exit();
                    }
                    if (!(command == null)) return [3 /*break*/, 2];
                    if (commandId != null) {
                        console.log("Invalid command '" + commandId + "'\n");
                    }
                    return [4 /*yield*/, printGlobalHelp()];
                case 1:
                    _a.sent();
                    return [3 /*break*/, 7];
                case 2:
                    if (!("help" in args && command.printHelp != null)) return [3 /*break*/, 4];
                    return [4 /*yield*/, command.printHelp()];
                case 3:
                    _a.sent();
                    return [3 /*break*/, 7];
                case 4:
                    _a.trys.push([4, 6, , 7]);
                    return [4 /*yield*/, command.run.apply(command, __spread([args], args._.slice(1)))];
                case 5:
                    exitCode = _a.sent();
                    process.exit(exitCode || 0);
                    return [3 /*break*/, 7];
                case 6:
                    error_1 = _a.sent();
                    if (error_1 instanceof CommandError) {
                        console.log("Error: ", error_1.message, "\n");
                        return [2 /*return*/, process.exit(1)];
                    }
                    else {
                        console.log("Fatal error: ", error_1.message);
                        throw error_1;
                    }
                case 7: return [2 /*return*/];
            }
        });
    });
}
/**
 * Prints the global help text.
 */
function printGlobalHelp() {
    console.log("Usage:\n  $ wca <command> [<input-glob>] [options]\n\nAvailable Commands:\n  analyze\tAnalyses components and emits results in a specified format.\n  diagnose\tAnalyses components and emits diagnostics to the console.\n  \nFor more info, run any command with the `--help` flag\n  $ wca analyze --help\n  $ wca diagnose --help\n  \nExamples:\n  $ wca analyze\n  $ wca analyze src --format markdown\n  $ wca analyze \"src/**/*.{js,ts}\" --outDir output\n  $ wca analyze my-element.js --outFile output.json\n  \n  $ wca diagnose\n  $ wca diagnose src\n  $ wca diagnose \"./src/**/*.{js,ts}\"\n  $ wca diagnose my-element.js\n");
}

export { AnalyzeCliCommand, cli };
